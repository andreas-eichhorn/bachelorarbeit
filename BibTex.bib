
@article{johnston_advances_2004,
	title = {Advances in dataflow programming languages},
	volume = {36},
	issn = {0360-0300, 1557-7341},
	url = {https://dl.acm.org/doi/10.1145/1013208.1013209},
	doi = {10.1145/1013208.1013209},
	abstract = {Many developments have taken place within dataﬂow programming languages in the past decade. In particular, there has been a great deal of activity and advancement in the ﬁeld of dataﬂow visual programming languages. The motivation for this article is to review the content of these recent developments and how they came about. It is supported by an initial review of dataﬂow programming in the 1970s and 1980s that led to current topics of research. It then discusses how dataﬂow programming evolved toward a hybrid von Neumann dataﬂow formulation, and adopted a more coarse-grained approach. Recent trends toward dataﬂow visual programming languages are then discussed with reference to key graphical dataﬂow languages and their development environments. Finally, the article details four key open topics in dataﬂow programming languages.},
	language = {en},
	number = {1},
	urldate = {2025-01-24},
	journal = {ACM Computing Surveys},
	author = {Johnston, Wesley M. and Hanna, J. R. Paul and Millar, Richard J.},
	month = mar,
	year = {2004},
	keywords = {notion},
	pages = {1--34},
	file = {PDF:C\:\\Users\\andre\\Zotero\\storage\\EXIT9ANP\\Johnston et al. - 2004 - Advances in dataflow programming languages.pdf:application/pdf},
}

@article{chen_iteration_2021,
	title = {Iteration vs. {Recursion}: {Two} {Basic} {Algorithm} {Design} {Methodologies}},
	volume = {52},
	issn = {0163-5700},
	shorttitle = {Iteration vs. {Recursion}},
	url = {https://dl.acm.org/doi/10.1145/3457588.3457601},
	doi = {10.1145/3457588.3457601},
	abstract = {Iteration and recursion are two essential approaches in Algorithm Design and Computer Programming. Both iteration and recursion are needed for repetitive processes in computing. An iterative structure is a loop in which a collection of instructions and statements will be repeated. A recursive structure is formed by a procedure that calls itself to make a complete performance, which is an alternate way to repeat the process.},
	number = {1},
	urldate = {2025-01-28},
	journal = {SIGACT News},
	author = {Chen, Li},
	month = mar,
	year = {2021},
	keywords = {notion},
	pages = {81--86},
	file = {Full Text PDF:C\:\\Users\\andre\\Zotero\\storage\\6A75P6EE\\Chen - 2021 - Iteration vs. Recursion Two Basic Algorithm Design Methodologies.pdf:application/pdf},
}

@article{noauthor_pdf_2024,
	title = {({PDF}) {Dataflow} {Architectures}},
	url = {https://www.researchgate.net/publication/234148580_Dataflow_Architectures},
	doi = {10.1146/annurev.cs.01.060186.001301},
	abstract = {PDF {\textbar} On Nov 28, 2003, Arvind and others published Dataflow Architectures {\textbar} Find, read and cite all the research you need on ResearchGate},
	language = {en},
	urldate = {2025-01-28},
	journal = {ResearchGate},
	month = oct,
	year = {2024},
	keywords = {notion},
	file = {Snapshot:C\:\\Users\\andre\\Zotero\\storage\\NLD2BZHN\\234148580_Dataflow_Architectures.html:text/html},
}

@article{ambler_visual_1990,
	title = {Visual forms of iteration that preserve single assignment},
	volume = {1},
	issn = {1045-926X},
	url = {https://www.sciencedirect.com/science/article/pii/S1045926X0580014X},
	doi = {10.1016/S1045-926X(05)80014-X},
	abstract = {Many visual languages follow the principle of single assignment, particularly those based on declarative programming paradigms. However, the notion of single assignment seems at odds with most forms of iteration. In this paper, we survey a variety of approaches to this problem, and then present the approach used in the visual language Forms/2.},
	number = {2},
	urldate = {2025-01-28},
	journal = {Journal of Visual Languages \& Computing},
	author = {Ambler, Allen L. and Burnett, Margaret M.},
	month = jun,
	year = {1990},
	keywords = {notion},
	pages = {159--181},
	file = {PDF:C\:\\Users\\andre\\Zotero\\storage\\KV2IM79L\\Ambler und Burnett - 1990 - Visual forms of iteration that preserve single assignment.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\andre\\Zotero\\storage\\FZ2W9VII\\S1045926X0580014X.html:text/html},
}

@article{mosconi_iteration_2000,
	title = {Iteration constructs in data-flow visual programming languages},
	volume = {26},
	issn = {0096-0551},
	url = {https://www.sciencedirect.com/science/article/pii/S0096055101000091},
	doi = {10.1016/S0096-0551(01)00009-1},
	abstract = {Many visual programming languages (VPLs) rely on the data-flow paradigm, probably because of its simple and intuitive functioning mechanism. However, there are cases where more powerful programming constructs are needed to deal with complex problems. For example, iteration is undoubtedly an important aspect of programming, and should allow repetitive behaviors to be specified in compact and easy ways. Most existing data-flow VPLs provide special constructs to implement iterations, therefore infringing the pure data-flow paradigm in favor of program simplicity. This paper has three main purposes: (1) To provide a survey of the mechanisms used by some representative data-flow VPLs to carry out iterations; (2) To investigate, given a pure data-flow VPL, what should be the minimum set of characteristics which, after being added to the VPL, allow iterations to be implemented; and (3) To show real data-flow iteration implementations which rely on the characteristics pertaining to such a minimum set.},
	number = {2},
	urldate = {2025-01-29},
	journal = {Computer Languages},
	author = {Mosconi, M. and Porta, M.},
	month = jul,
	year = {2000},
	keywords = {Data-flow visual languages, Iterations, notion, Visual programming},
	pages = {67--104},
	file = {ScienceDirect Full Text PDF:C\:\\Users\\andre\\Zotero\\storage\\7J4GZH8Y\\Mosconi und Porta - 2000 - Iteration constructs in data-flow visual programming languages.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\andre\\Zotero\\storage\\K6BC764P\\S0096055101000091.html:text/html},
}

@inproceedings{fan_loop_2022,
	title = {A {Loop} {Optimization} {Method} for {Dataflow} {Architecture}},
	url = {https://ieeexplore.ieee.org/document/10074943},
	doi = {10.1109/HPCC-DSS-SmartCity-DependSys57074.2022.00059},
	abstract = {Dataflow architecture is a promising parallel computing platform that provides high performance, high efficiency and flexibility. Since the execution of a loop is usually the most time-consuming in a program, extracting sufficient loop-level parallelism is an essential task of dataflow architecture. However, existing methods often result in low execution performance and poor hardware utilization due to the imbalance among dataflow graph nodes and the non-preemptive mechanism. To tackle these problems, this paper makes three contributions: 1) A highly effective dataflow graph balancing method is developed to improve the utilization. 2) An enhanced dataflow execution model is proposed, which adapts a novel preemptive mechanism to further improve the hardware utilization and performance. 3) A decoupled dataflow architecture is designed to efficiently support our proposed dataflow execution model. Experiment shows that our methods can achieve an average of 2.61 ×performance improvement and 2.5 ×utilization improvement compared to the state-of-the-art methods with acceptable overhead.},
	urldate = {2025-01-31},
	booktitle = {2022 {IEEE} 24th {Int} {Conf} on {High} {Performance} {Computing} \& {Communications}; 8th {Int} {Conf} on {Data} {Science} \& {Systems}; 20th {Int} {Conf} on {Smart} {City}; 8th {Int} {Conf} on {Dependability} in {Sensor}, {Cloud} \& {Big} {Data} {Systems} \& {Application} ({HPCC}/{DSS}/{SmartCity}/{DependSys})},
	author = {Fan, Zhihua and Li, Wenming and Liu, Tianyu and Tang, Shengzhong and Wang, Zhen and An, Xuejun and Ye, Xiaochun and Fan, Dongrui},
	month = dec,
	year = {2022},
	keywords = {Adaptation models, Computer architecture, Costs, Dataflow Architecture, Dataflow Execution Model, Dataflow Graph Pipelining, Hardware, Hazards, Loops, notion, Optimization methods, Task analysis},
	pages = {202--211},
	file = {Full Text PDF:C\:\\Users\\andre\\Zotero\\storage\\G3L8FDWD\\Fan et al. - 2022 - A Loop Optimization Method for Dataflow Architecture.pdf:application/pdf},
}

@article{gevay_handling_2021,
	title = {Handling {Iterations} in {Distributed} {Dataflow} {Systems}},
	volume = {54},
	issn = {0360-0300},
	url = {https://dl.acm.org/doi/10.1145/3477602},
	doi = {10.1145/3477602},
	abstract = {Over the past decade, distributed dataflow systems (DDS) have become a standard technology. In these systems, users write programs in restricted dataflow programming models, such as MapReduce, which enable them to scale out program execution to a shared-nothing cluster of machines. Yet, there is no established consensus that prescribes how to extend these programming models to support iterative algorithms. In this survey, we review the research literature and identify how DDS handle control flow, such as iteration, from both the programming model and execution level perspectives. This survey will be of interest for both users and designers of DDS.},
	number = {9},
	urldate = {2025-01-31},
	journal = {ACM Comput. Surv.},
	author = {Gévay, Gábor E. and Soto, Juan and Markl, Volker},
	month = oct,
	year = {2021},
	keywords = {notion},
	pages = {199:1--199:38},
	file = {Full Text PDF:C\:\\Users\\andre\\Zotero\\storage\\68SV5ZSA\\Gévay et al. - 2021 - Handling Iterations in Distributed Dataflow Systems.pdf:application/pdf},
}

@article{alves_concurrency_2021,
	title = {Concurrency {Analysis} in {Dynamic} {Dataflow} {Graphs}},
	volume = {9},
	issn = {2168-6750},
	url = {https://ieeexplore.ieee.org/document/8269827},
	doi = {10.1109/TETC.2018.2799078},
	abstract = {Dynamic dataflow scheduling enables effective exploitation of concurrency while making parallel programming easier. To this end, analyzing the inherent degree of concurrency available in dataflow graphs is an important task, since it may aid compilers or programmers to assess the potential performance a program can achieve via parallel execution. However, traditional concurrency analysis techniques only work for DAGs (directed acyclic graphs), hence the need for new techniques that contemplate graphs with cycles. In this paper we present techniques to perform concurrency analysis on generic dynamic dataflow graphs, even in the presence of cycles. In a dataflow graph, nodes represent instructions and edges describe dependencies. The novelty of our approach is that we allow concurrency between different iterations of the loops. Consequently, a set of concurrent nodes may contain instructions from different loops that can be proven independent. In this work, we provide a set of theoretical tools for obtaining bounds and illustrate implementation of parallel dataflow runtime on a set of representative graphs for important classes of benchmarks to compare measured performance against derived bounds.},
	number = {1},
	urldate = {2025-01-31},
	journal = {IEEE Transactions on Emerging Topics in Computing},
	author = {Alves, Tiago A. O. and Marzulo, Leandro A. J. and Kundu, Sandip and França, Felipe M. G.},
	month = jan,
	year = {2021},
	note = {Conference Name: IEEE Transactions on Emerging Topics in Computing},
	keywords = {Concurrent computing, Dataflow, distributed computing, Dynamic scheduling, Heuristic algorithms, high performance computing, Measurement, notion, Optimal scheduling, parallel programming, Performance analysis, Tools},
	pages = {44--54},
	file = {Full Text PDF:C\:\\Users\\andre\\Zotero\\storage\\RP6SG5AN\\Alves et al. - 2021 - Concurrency Analysis in Dynamic Dataflow Graphs.pdf:application/pdf},
}

@inproceedings{ye_loop_2024,
	title = {Loop {Unrolling} {Based} on {SLP} and {Register} {Pressure} {Awareness}},
	url = {https://ieeexplore.ieee.org/document/10702289},
	doi = {10.1109/ICNC-FSKD64080.2024.10702289},
	abstract = {Loop unrolling is a common compiler optimization technique that reduces the execution count of loop branch instructions and improves program performance by merging multiple iterations of a loop body into a single iteration. In LLVM, the native loop unrolling model considers only the impact of the number of instructions within the loop body when computing the unrolling factor, without accounting for subsequent optimizations and register resources. To address this issue, a new loop unrolling model is proposed that takes into account subsequent superword level parallelism (SLP) vectorization and register pressure. When computing the unrolling factor, the model uses the benefit for SLP (BSLP) model to identify loops that can be vectorized by SLP after loop unrolling and calculates the unrolling factor to support subsequent SLP vectorization. The register pressure-aware loop unrolling (RPLU) model adjusts the unrolling factor to mitigate excessive register pressure, thereby reducing the impact of register spills. Experimental results show that, compared to the loop unrolling model in LLVM, this model can compute more effective loop unrolling factors and improve program performance. The average speedup on the SPEC CPU 2006 benchmark suite is 2.0\%, with a maximum speedup of 5.1\%, and the average speedup on the TSVC benchmark suite is 5.1\%, with a maximum speedup of 34.4\%.},
	urldate = {2025-02-01},
	booktitle = {2024 20th {International} {Conference} on {Natural} {Computation}, {Fuzzy} {Systems} and {Knowledge} {Discovery} ({ICNC}-{FSKD})},
	author = {Ye, Zilong and Jiao, Jiye},
	month = jul,
	year = {2024},
	keywords = {Benchmark testing, compiler optimization, Computational modeling, Fuzzy systems, Knowledge discovery, loop unrolling, Merging, notion, Optimization, Parallel processing, Program processors, register pressure, Registers, unrolling factor, vectorization},
	pages = {1--6},
	file = {Full Text PDF:C\:\\Users\\andre\\Zotero\\storage\\QP4PNEZ5\\Ye und Jiao - 2024 - Loop Unrolling Based on SLP and Register Pressure Awareness.pdf:application/pdf;IEEE Xplore Abstract Record:C\:\\Users\\andre\\Zotero\\storage\\88EZF5I5\\10702289.html:text/html},
}

@inproceedings{lucanin_visual_2011,
	title = {A visual programming language for drawing and executing flowcharts},
	url = {https://ieeexplore.ieee.org/document/5967331},
	abstract = {With recent advances in graphical user interfaces, more and more tasks on computers have become easier to perform. Out of the belief that creating computer programs can also be one of them, visual programming languages (VPLs) have emerged. The goal of VPLs is to shift a part of work from the programmer to the IDE so that the programmer can focus more on algorithm logic than the syntax of the implementation programming language. In this article, the methods required to build a VPL are presented, with an emphasis on a novel method of code generation in a WHILE language. Also, the methods for achieving basic principles of VPLs will be shown — suitable visual presentation of information and guiding the programmer in the right direction using constraints. These methods are demonstrated on an example of vIDE, a VPL based on the Eclipse integrated development environment (IDE). The design of vIDE with respect to the Eclipse Graphical Modeling Framework (GMF) is described. The concept of a flowchart graphical notation is examined in contrast with the algorithm model it maps to. Finally, the disambiguity of the model representation of an algorithm is discussed and the methods for transforming it to an actual implementation in a programming language.},
	urldate = {2025-02-01},
	booktitle = {2011 {Proceedings} of the 34th {International} {Convention} {MIPRO}},
	author = {Lučanin, Dražen and Fabek, Ivan},
	month = may,
	year = {2011},
	keywords = {algorithm, Computer languages, Data structures, Eclipse, flowchart, Flowcharts, GMF, GOTO, GUI, model, notion, OCL, programming language, Programming profession, Python, Syntactics, vIDE, visual programming, Visualization, VPL, WHILE},
	pages = {1679--1684},
	file = {Full Text PDF:C\:\\Users\\andre\\Zotero\\storage\\DZEB6CDF\\Lučanin und Fabek - 2011 - A visual programming language for drawing and executing flowcharts.pdf:application/pdf;IEEE Xplore Abstract Record:C\:\\Users\\andre\\Zotero\\storage\\HHCJ3R2P\\5967331.html:text/html},
}

@article{davis_data_1982,
	title = {Data {Flow} {Program} {Graphs}},
	url = {https://scholarship.claremont.edu/hmc_fac_pub/285},
	journal = {All HMC Faculty Publications and Research},
	author = {Davis, Alan and Keller, Robert},
	month = feb,
	year = {1982},
	keywords = {notion},
	file = {"Data Flow Program Graphs" by Alan L. Davis and Robert M. Keller:C\:\\Users\\andre\\Zotero\\storage\\RWLIJKZH\\285.html:text/html;PDF:C\:\\Users\\andre\\Zotero\\storage\\JSZE5UBZ\\Davis und Keller - 1982 - Data Flow Program Graphs.pdf:application/pdf},
}

@inproceedings{li_termination_2012,
	title = {Termination {Analysis} of {Multipath} {Loop} {Programs}},
	url = {https://ieeexplore.ieee.org/document/6300499/?arnumber=6300499},
	doi = {10.1109/ICCIS.2012.311},
	abstract = {In this paper, we analyze termination of multipath linear loop programs by combining the trial difference method and calculation of loop complexity upper bound. Though this method is not complete, it is useful to verify termination of multipath linear loop programs, because it is practical and it is very easy to implement.},
	urldate = {2025-02-02},
	booktitle = {2012 {Fourth} {International} {Conference} on {Computational} and {Information} {Sciences}},
	author = {Li, Lingna},
	month = aug,
	year = {2012},
	keywords = {cation, Complexity theory, Computers, Educational institutions, loop complexity upper bound, multipath loop program, notion, Optimization, Polynomials, program veriﬁ, Radiation detectors, termination, the trial difference method, Upper bound},
	pages = {313--316},
	file = {Full Text PDF:C\:\\Users\\andre\\Zotero\\storage\\KG6I59IA\\Li - 2012 - Termination Analysis of Multipath Loop Programs.pdf:application/pdf;IEEE Xplore Abstract Record:C\:\\Users\\andre\\Zotero\\storage\\WIE5SEFX\\6300499.html:text/html},
}

@inproceedings{charntaweekhun_visual_2006,
	title = {Visual {Programming} using {Flowchart}},
	url = {https://ieeexplore.ieee.org/document/4141379},
	doi = {10.1109/ISCIT.2006.339940},
	abstract = {Nowadays a computer programming become the fundamental knowledge for people studying or working in a computer field, e.g. computer engineering, computer science, information technology, etc. Programmer not only considers the algorithm carefully but also performs the coding according to the syntax of programming language used. Therefore writing a computer program is a difficult task, especially for a beginner. In fact, a novice often uses a flowchart as a tool to help him summarize the idea into all necessary steps of solution, but this flowchart cannot be understood by the computer. It must be converted to the program by using some programming language and then be compiled and run. The visual programming using flowchart proposed in this paper allows the programmer to write the program in the format of flowchart, then compiles and run, without the coding step. There is no necessity to remember the syntax of any programming languages. It takes the benefits of easy-to-understand and easy-to-perform of the flowchart, whereas eliminates the weakness of a conventional programming, e.g. the requirement of remembering the syntax, the error in coding step. Furthermore, a debugging of program by the proposed system is straightforward and easy to discover the error. The proposed system could be used as a tool for teaching the basic concept of structural programming as well. Experimental results show the powerfulness, easiness, and user-friendliness of the proposed system},
	urldate = {2025-02-02},
	booktitle = {2006 {International} {Symposium} on {Communications} and {Information} {Technologies}},
	author = {Charntaweekhun, Kanis and Wangsiripitak, Somkiat},
	month = oct,
	year = {2006},
	keywords = {Algorithm design and analysis, Computer errors, Computer languages, Computer science, Education, Electronic mail, Flowcharts, Knowledge engineering, notion, Programming profession, Writing},
	pages = {1062--1065},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\andre\\Zotero\\storage\\S8PNF799\\4141379.html:text/html;PDF:C\:\\Users\\andre\\Zotero\\storage\\8BD86BNG\\Charntaweekhun und Wangsiripitak - 2006 - Visual Programming using Flowchart.pdf:application/pdf},
}

@article{carlisle_raptor_2009,
	title = {{RAPTOR}: {A} {VISUAL} {PROGRAMMING} {ENVIRONMENT} {FOR} {TEACHING} {OBJECT}-{ORIENTED} {PROGRAMMING}},
	abstract = {Learning object-oriented programming usually involves learning a programming language with a large amount of complexity. Students very often spend more time dealing with syntactical complexity than learning the underlying principles of object-orientation or solving the problem. Additionally, the textual nature of most programming environments works against the learning style of the majority of students. RAPTOR is an iconic programming environment, designed specifically to help students visualize classes and methods and limit syntactic complexity. RAPTOR programs are created visually using a combination of UML and flowcharts. The resulting programs can be executed visually within the environment and converted to Java.},
	language = {en},
	author = {Carlisle, Martin C},
	year = {2009},
	keywords = {notion},
	file = {PDF:C\:\\Users\\andre\\Zotero\\storage\\AZ9FEIBS\\Carlisle - 2009 - RAPTOR A VISUAL PROGRAMMING ENVIRONMENT FOR TEACHING OBJECT-ORIENTED PROGRAMMING.pdf:application/pdf},
}

@book{aho_compilers_2007,
	address = {Boston Munich},
	edition = {2. ed., Pearson internat. ed},
	title = {Compilers: principles, techniques, \& tools},
	isbn = {978-0-321-48681-3 978-0-321-49169-5},
	shorttitle = {Compilers},
	language = {en},
	publisher = {Pearson Addison-Wesley},
	editor = {Aho, Alfred V. and Lam, Monica S. and Sethi, Ravi and Ullman, Jeffrey D.},
	year = {2007},
	keywords = {notion},
	file = {PDF:C\:\\Users\\andre\\Zotero\\storage\\LTS5ZZ3G\\Aho et al. - 2007 - Compilers principles, techniques, & tools.pdf:application/pdf},
}

@article{burnett_scaling_1995,
	title = {Scaling up visual programming languages},
	volume = {28},
	issn = {1558-0814},
	url = {https://ieeexplore.ieee.org/document/366157},
	doi = {10.1109/2.366157},
	abstract = {The directness, immediacy, and simplicity of visual programming languages are appealing. The question is, can VPLs be effectively applied to large scale programming problems while retaining these characteristics. In scaling up, the problem is how to expand applicability without sacrificing the goals of better logic expression and understanding. From a size standpoint, scaling up refers to the programmer's ability to apply VPLs in larger programs. Such programs range from those requiring several days' work by a single programmer to programs requiring months of work, large programming teams, and large data structures. From a problem domain standpoint, scaling up refers to suitability for many kinds of problems. These range from visual application domains-such as user interface design or scientific visualization-to general purpose programming in such diverse areas as financial planning, simulations, and real time applications with explicit timing requirements. To illustrate the scaling up problem, we discuss nine major subproblems and describe emerging solutions from existing VPL systems. First, we examine representation issues, including static representation, screen real estate, and documentation. Next, we examine programming language issues-procedural abstraction, interactive visual data abstraction, type checking, persistence, and efficiency. Finally, we look at issues beyond the coding process.{\textless}{\textgreater}},
	number = {3},
	urldate = {2025-02-05},
	journal = {Computer},
	author = {Burnett, M.M. and Baker, M.J. and Bohus, C. and Carlson, P. and Yang, S. and Van Zee, P.},
	month = mar,
	year = {1995},
	note = {Conference Name: Computer},
	keywords = {Computer languages, Data structures, Data visualization, Documentation, Financial management, Large-scale systems, Logic programming, notion, Programming profession, Timing, User interfaces},
	pages = {45--54},
	file = {Full Text PDF:C\:\\Users\\andre\\Zotero\\storage\\6WA5NKGL\\Burnett et al. - 1995 - Scaling up visual programming languages.pdf:application/pdf;IEEE Xplore Abstract Record:C\:\\Users\\andre\\Zotero\\storage\\VX2MVLHT\\366157.html:text/html},
}

@book{hopcroft_introduction_2007,
	address = {Boston},
	edition = {3rd ed},
	title = {Introduction to automata theory, languages, and computation},
	isbn = {978-0-321-45536-9 978-0-321-46225-1 978-0-321-45537-6},
	language = {en},
	publisher = {Pearson/Addison Wesley},
	author = {Hopcroft, John E. and Motwani, Rajeev and Ullman, Jeffrey D.},
	year = {2007},
	note = {OCLC: ocm69013079},
	keywords = {Computational complexity, Formal languages, Machine theory, notion},
	file = {PDF:C\:\\Users\\andre\\Zotero\\storage\\PHAHQCSH\\Hopcroft et al. - 2007 - Introduction to automata theory, languages, and computation.pdf:application/pdf},
}

@article{green_usability_1996,
	title = {Usability {Analysis} of {Visual} {Programming} {Environments}: {A} ‘{Cognitive} {Dimensions}’ {Framework}},
	volume = {7},
	issn = {1045-926X},
	shorttitle = {Usability {Analysis} of {Visual} {Programming} {Environments}},
	url = {https://www.sciencedirect.com/science/article/pii/S1045926X96900099},
	doi = {10.1006/jvlc.1996.0009},
	abstract = {The cognitive dimensions framework is a broad-brush evaluation technique for interactive devices and for non-interactive notations. It sets out a small vocabulary of terms designed to capture the cognitively-relevant aspects of structure, and shows how they can be traded off against each other. The purpose of this paper is to propose the framework as an evaluation technique for visual programming environments. We apply it to two commercially-available dataflow languages (with further examples from other systems) and conclude that it is effective and insightful; other HCI-based evaluation techniques focus on different aspects and would make good complements. Insofar as the examples we used are representative, current VPLs are successful in achieving a good ‘closeness of match’, but designers need to consider the ‘viscosity ’ (resistance to local change) and the ‘secondary notation’ (possibility of conveying extra meaning by choice of layout, colour, etc.).},
	number = {2},
	urldate = {2025-02-05},
	journal = {Journal of Visual Languages \& Computing},
	author = {Green, T. R. G. and Petre, M.},
	month = jun,
	year = {1996},
	keywords = {notion},
	pages = {131--174},
	file = {PDF:C\:\\Users\\andre\\Zotero\\storage\\B62AZVQA\\Green und Petre - 1996 - Usability Analysis of Visual Programming Environments A ‘Cognitive Dimensions’ Framework.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\andre\\Zotero\\storage\\XA8T5MWK\\S1045926X96900099.html:text/html},
}

@article{kurihara_programming_2015,
	series = {Proceedings of the 2015 {International} {Conference} on {Soft} {Computing} and {Software} {Engineering} ({SCSE}'15)},
	title = {A {Programming} {Environment} for {Visual} {Block}-{Based} {Domain}-{Specific} {Languages}},
	volume = {62},
	issn = {1877-0509},
	url = {https://www.sciencedirect.com/science/article/pii/S1877050915025879},
	doi = {10.1016/j.procs.2015.08.452},
	abstract = {Visual block-based programming is useful for various users such as novice programmers because it provides easy operations and improves the readability of programs. Also, in programming education, it is known to be effective to initially present basic language features and then gradually make more advanced features available. However, the cost of implementing such visual block-based languages remains a challenge. In this paper, we present a programming environment for providing visual block-based domain- specific languages (visual DSLs) that are translatable into various programming languages. In our environment, programs are built by combining visual blocks expressed in a natural language. Blocks represent program elements such as operations and variables. Tips represent snippets, and macro blocks represent procedures. Using Tips and macros make code more abstract, and reduce the number of blocks in code. Visual DSLs can be a front-end for various languages. It can be easily restricted and extended by adding and deleting blocks. We applied our programming environment to Processing, an educational programming language for media art. We show that the environment is useful for novice programmers who learn basic concepts of programming and the features of Processing.},
	urldate = {2025-02-05},
	journal = {Procedia Computer Science},
	author = {Kurihara, Azusa and Sasaki, Akira and Wakita, Ken and Hosobe, Hiroshi},
	month = jan,
	year = {2015},
	keywords = {Domain-Specific Language, notion, Programming Environment, Visual Programming},
	pages = {287--296},
	file = {PDF:C\:\\Users\\andre\\Zotero\\storage\\LEV465JD\\Kurihara et al. - 2015 - A Programming Environment for Visual Block-Based Domain-Specific Languages.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\andre\\Zotero\\storage\\PJPBABW3\\S1877050915025879.html:text/html},
}

@article{hils_visual_1992,
	title = {Visual languages and computing survey: {Data} flow visual programming languages},
	volume = {3},
	issn = {1045-926X},
	shorttitle = {Visual languages and computing survey},
	url = {https://www.sciencedirect.com/science/article/pii/1045926X9290034J},
	doi = {10.1016/1045-926X(92)90034-J},
	abstract = {The data flow model is a popular model on which to base a visual programming language. This paper describes alternatives available to a designer of data flow languages, describes many of the languages, discusses some strengths of the languages, and discusses some unsolved problems in the design of data flow languages.},
	number = {1},
	urldate = {2025-02-06},
	journal = {Journal of Visual Languages \& Computing},
	author = {Hils, Daniel D},
	month = mar,
	year = {1992},
	keywords = {notion},
	pages = {69--101},
	file = {1-s2.0-1045926X9290034J-main:C\:\\Users\\andre\\Zotero\\storage\\IAHBWX48\\1-s2.0-1045926X9290034J-main.pdf:application/pdf;Eingereichte Version:C\:\\Users\\andre\\Zotero\\storage\\XGB9BITC\\Hils - 1992 - Visual languages and computing survey Data flow visual programming languages.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\andre\\Zotero\\storage\\3TWMX6US\\1045926X9290034J.html:text/html},
}

@article{kodosky_labview_2020,
	title = {{LabVIEW}},
	volume = {4},
	url = {https://dl.acm.org/doi/10.1145/3386328},
	doi = {10.1145/3386328},
	abstract = {LabVIEW™ is unusual among programming languages in that we did not intend to create a new language but rather to develop a tool for non-programmer scientists and engineers to assist them in automating their test and measurement systems. Prior experience creating software for controlling instruments led us to the perspective that the software ought to be modeled as a hierarchy of ”virtual instruments”. The lowest level virtual instruments were simply reflections of the individual physical instruments they controlled. Higher level virtual instruments combined lower level ones to deliver more complex measurements. A frequency response virtual instrument could be implemented using a voltmeter and a sine-wave generator inside a loop that stepped through a frequency range. This was mostly an abstract concept at the time because it was hard to imagine how an existing language or tool could provide the rich yet intuitive experience of using a real instrument. Inspired by the first Macintosh computer, we quickly realized the graphical user interface would be a natural way to interact with a virtual instrument, but it also sparked our imaginations about using graphics for creating software at a higher level of abstraction. The February 1982 issue of IEEE Computer was devoted to data-flow models of computation, and it convinced us that graphical data-flow diagrams needed to be part of the solution. The major difficulty we saw, however, was the need to use cycles in the data-flow diagram to represent loops. Cycles increased complexity and made diagrams hard to understand and even harder to create. This concern led to a major innovation in creating LabVIEW: merging structured programming concepts with data-flow. We represented control-flow structures as boxes in a data-flow diagram. We knew how to reason about loops, so we could introduce them as first class elements of the graphical representation rather than being constructed from lower-level elements. A box could encapsulate the semantics of the iterative behavior; it could clearly separate the body of the loop (the diagram inside the box) from the code before and after the loop (the diagram outside the box); and, its boundary could hold iteration state information. Those fundamental concepts of ”graphical”, ”structured” and ”data-flow” enabled us to propose a software product. We staffed up a small skunkworks team to implement it. We called it LabVIEW. It was to be an engineer’s tool for automating measurement systems. At first, we were reluctant to admit that we had created a graphical programming language. When we finally did, we nicknamed it G, for Graphical language, so we could talk about the language as distinct from the integrated development environment (IDE), LabVIEW. In practice, almost everyone refers to both the language and the IDE as LabVIEW. Without intending to do so, we created a programming language radically different from those that came before, pioneering techniques of graphically creating and viewing code, eliminating manual memory management without adding garbage collection overhead, and anticipating the massively parallel systems of the modern era. LabVIEW continues to evolve and thrive after more than 30 years.},
	number = {HOPL},
	urldate = {2025-02-06},
	journal = {Proc. ACM Program. Lang.},
	author = {Kodosky, Jeffrey},
	month = jun,
	year = {2020},
	keywords = {notion},
	pages = {78:1--78:54},
	file = {Full Text PDF:C\:\\Users\\andre\\Zotero\\storage\\7I2QFWDI\\Kodosky - 2020 - LabVIEW.pdf:application/pdf},
}
