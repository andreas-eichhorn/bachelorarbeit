\documentclass{article}
\usepackage{syntax}
\usepackage{tikz}
\usetikzlibrary{automata, positioning}

\begin{document}
    %Notizen
    folgende Begriffe sollen definiert werden:

    Visual Programming Language

    Grammatik

    Domain Specific Language

    Schleifen

    Flowchart

    (Fixpunktberechnung)
    \newpage
    \tableofcontents
    %Einleitung
    \newpage
    \section{Einleitung}
    %Haupteil
    \newpage
    \section{Terminologie}
    \subsection{Schleifen}
    Eine Schleife ist eine Kontrollstruktur, welche einen Code-Abschnitt mehrmals ausführt. \cite{22}
    Sie stellt dabei oftmals die zeitintensivste Komponente eines Programms dar, weil die Ausführung der Schleife sehr viel Zeit in anspruch nehmen kann. \cite{1}
    Der Algrorithmus der Kontrollstruktur kann bei iterativ oder rekursiv umgesetzt werden. Beide Ansätze haben dabei das gleiche Ziel, aber setzen die Schleife anders um. Bei der Iteration wird die Schleife mehrmals wiederholt wird. Bei der Rekursion ruft sich die zu wiederholende Funktions mehrmals selbst auf.
    Die Iteration verwendet dabei einen Akkumulativenansatz, welcher das zu lösende Problem schrittweise löst und diesen Vorgang solange wiederholt bis eine vordefinierte Abbruchbedingung erreicht wurden ist.
    Die Rekursion verwendet keinen Akkumulativenansatz, sondern reduziert das eigentlich zu lösende Problam auf mehrere (Teil-)Probleme. Für die Teilprobleme werden dann einzelne Lösungen gesucht, welche anschließend zusammengesatz werden um das eigentliche Problem zu lösen. \cite{3}
    Laut Chen L. spiegelt die Iteration das menschliche Denken wieder und ist daher besonders für lineare Probleme geeignet. Hingegen die Rekursion für lineare oder sequentielle Probleme geeignet sind, welche Zwischenergebnisse oder Teillösungen benötigen. \cite{3}
    Die Iteration lässt sich dabei in zeitabhängige oder horizontale Iteration unterteilen. Bei der zeitabhängigen Iteration ist das Ergebniss des aktuellen Schleifendurchlaufes von dem Ergebniss des vorherigen Schleifendurchlaufes abhängig. Hingegen bei der horizontalrn Iteration die Ergbenisse der Schelifendurchläufe unabhängig voneinander sind. \cite{5}
    \subsection{Datenfluss-basierte Systeme}
    \newpage
    \section{Aufbau der domainspezifischen Sprache}
    Im nachfolgenden Kapitel möchte ich die zugrundeliegende Grammatik beschreiben. Am Anfang möchte ich auf die Notation eingehen.\\\\
    Die zugrundeliegende Grammatik basiert auf der Backus-Naur-Form (BNF) Notation. Der Aufbau einer BNF wird anhand der Grammatik~\ref{BNF} erklärt
    <symbol> sind nichtterminale
    ::= bedeutet dass symbol durch _expression_ ersetzt wird
    _expression_ ist eine sequenze von nichterminalen und terminale
    Kleene-Stern * wiederholung
    Alternation \textbar  oder
    Sequenz erlaubt auch Klammern um die Reihenfolge der Regel zu definieren
    Softwareprüfung lääst sich visuall von zwei seiten betrachen. 
    \begin{grammar}
        <symbol> ::= _expression_
    \end{grammar}
    \textbf{Grammatik TODO} Backus-Naur-Form\\\\\\
    \label{BNF}
    Grammatik lässt sich in 3 Ebenenunterteilen Prüfungslogik, Datenverarbeitung und Typsystem
    Prüfungslogik führt Entscheidung im Prüfungsablauf aus und bestimmt die Reihenfolge der Aktionen. außerdem datenerfassung
    Datenverarbeitung ist für die Datentranformation auswertung zustädnig. Also Funktionen, welche keine Nebeneffekte besitzen, weil sie unabhängig von der restoichen Softwareprüfung stattfinden.
    Typsystem ermöglicht die statische analyse der ausführbarkeit
    Softwareprüfung lääst sich visuall von zwei seiten betrachen. 
    Einmal als Datenflussgraphen, indem Teil-Funktionen als Blöcke dargestellt werden und Funktionsparamter/Ergebnisse als Ports.
    Einmal als Aktivitätsdiagramm, in dem nur Startzustand, Endzustände, Aktions- und Entscheidungsblöcke dargeste
    \subsection{Prüfungslogik}
    Das Aktivitätsmodell  $<ActivityModel>$ besteht aus einer Reihe von Aktivitäten $<Activity>$.
    Aktivitäten können dabei entweder eine Startmarkierung, eine Aktivitätsaktion, einem Vergleich oder visualles Label sein.
    Die Startmarkierung muss pro Prüfungslogik genau einmal vorkommen.
    Ein vergleich kann dabei entweder eine Binärentscheidung oder eine Validierungsentscheidung sein.   
    Die Validierungsentscheidung nimmt als Eingabe einen Wert und überprüft ob diese Werte vorhanden sind.
    Die Binärentscheidung nimmt als Parameter zweite Werte, einen Vergleichoperatur und eine referenz zu einer Funtkion. Dabei werden beide Werte als Eingabe für die referenzierte Funktion verwendet.
    Als Vergleichoperatoren stehen $=$ und $\neq$ sowie Relationale Operatoren zur verfügung.
    Eine Aktivitätaktion <ActivityAction> kann dabei einer der folgenden Aktionen ausführen:
    Bevor das Ergbeniss aus der vorherigen Aktionsaktivität verwendet wird, kann eine Transformation auf dieses Ergebniss angewendet werden.
    \begin{itemize}
        \item Senden von Hauptuntersuchungs-Adatper-Anfragen (A1)
        \item Lesen einer JSON Datei (A2)
        \item Ausführung einer Datenverarbeitung (A3)
    \end{itemize}
    A1 nimmt als Parameter den Namen der auszuführenden Anfrage, eine Beschreibung für den debugger, eine Liste von anzusprechnenden System im Fahrzeig und die maximale Zeitdrauer einer Anfrage.
    A2 nimmt als Eingabe den Typ der zu ladenenden Datei und die dazugehörige URI.
    A3\\
    \begin{grammar}
        <ActivityModel> ::= <Activity>* <ActivityConnection>

        <Activity> ::= <ActivityStart>
        | <ActivityAction>
        | <ActivityCondition>
        | <ActivityDisplay>

        <ActivityStart> ::= $\epsilon$

        <ActivityAction> ::= <ActivityFlowCall>
        | <ActivityPitaBuildInforRequest>
        | <ActivityLoadExternalData>

        <ActivityFlowCall> ::= ref(FlowTemplate) <ActivityPortValue>* <TemplateParameterValue>* <ValueTransformation>*

        <ActivityPitaBuildInforRequest> ::= <string abdFilename> <string requestAlias> <string expectedSystems>* <number timeout>

        <ActivityLoadExternalData> ::= <Type dataType> <string dataSource>

        <ActivityPortValue> ::= <FlowPortValue>
        | <ActivityPortRefernce>

        <FlowPortValue> ::= <string>
        | <number>
        | <bool>
        | <date>
        | <FlowPortValue>*

        <ActivityPortRefernce> ::= ref(ActivityAction) (ValueTransformation)*

        <ValueTransformation> ::= <string objectReference>
        | <number listIndex>

        <ActivityCondition> ::= <ActivityBinaryCondition>
        | <ActivityValidityCondition>

        <ActivityBinaryCondition> ::= ref(FlowTemplate) <ActivityBinaryConditionOperator> <ActivityPortValue left> <ActivityPortValue right>

        <ActivityValidityCondition> ::= <ActivityPortValue>*

        <ActivityBinaryCondition> ::= '='
        | '$\neq$' 
        | '\textless' 
        | '$\leq$' 
        | '\textgreater' 
        | '$\geq$'

        <ActivityDisplay> ::= <ActivityDisplayField>*

        <ActivityDisplayField> ::= <string label> <string color> ref(ActivityAction)
    \end{grammar}
    \textbf{Grammatik TODO} Aktivitätsmodell
    \newpage
    \subsection{Datenverarbeitungs}
    Eingabe <FlowInputPort> und Ausgabe $<FlowOutputPort>$
    Funktionen höherer Ordnung $<FlowLamda>$
    Eine Funktion höher Ordnung besteht aus zustzälciehn Eingabe- und Ausgabeports
    Eingabe- und Ausgabeports nehmen als Parameter einen Namen des Ports, den Typ und ob Fehlererlaub ist.

    Ein Funktions Template $<FlowTemplate>$ besteht aus einer Funktion $Flow$ und belieg vielen Parametern $<TemplateParameter>$
    Die Parameter generieren Port- und Lambda-Defintion
    Funktionen welche vom Autorensystem $<LibraryFlow>$ und selbst definierte Funktionen $<FlowModel>$

    Ein Flow-Modell ist ein DAG bei dem mehrere Funktionen mitienander verbunden werden. Einzelne Funktionen werden Nodes $<FlowNode>$ genannt.
    Das Flow-Modell wird durch eine $<FlowInstance>$, Reihe von Funktionen und Verbidnugen definiert.
    Die Funktion kann dabei eine Eingabe <$FlowNodeInput>$, eine Ausgabe $<FlowNodeOutput>$, einer Lambda Referenz $<FlowNodeLambda>$ oder eine Funtkions Referenz $FlowNodeFlowCall$
    Konstante Werte $FlowPortValue$
    \begin{grammar}
        <FlowInstance> ::= <FlowOutputPort lambdaArguments>* <FlowInputPort lambdaArguments>* <FlowLambda>*
        
        <FlowLambda> ::= <FlowOutputPort lambdaArguments>* <FlowInputPort lambdaArguments>*

        <FlowInputPort> ::= <string name> <Type> <bool acceptsError>

        <FlowOutputPort> ::= <string name> <Type> <bool producesError>
    \end{grammar}
    \textbf{Grammatik TODO} Flow-Instanz
    \begin{grammar}
        <FlowTemplate> ::= <Flow> <TemplateParameter>*

        <Flow> ::= <LibraryFlow> | <FlowModel>
        
        <LibraryFlow> ::= $\epsilon$

        <TemplateParameter> ::= 'String' | 'Number' | 'Bool' | <TemplateParameterList>
        
        <TemplateParameterList> ::= <TemplateParameter>
    \end{grammar}
    \textbf{Grammatik TODO} Flow-Template
    \begin{grammar}
        <FlowModel> ::= <FlowInstance> <FlowNode>* <FlowConnection>*

        <FlowNode> ::= <FlowNodeOutput> | <FlowNodeInput> | <FlowNodeLambda> | <FlowNodeFlowCall>
       
        <FlowNodeOutput> ::= ref(FlowOutputPort) <FlowPortValue>

        <FlowNodeLambda> ::= ref(FlowLambda) <FlowPortValue>*

        <FlowNodeFlowCall> ::= ref(FlowTemplate) <FlowPortValue>* <TemplateParameterValue>*
    
        <FlowConnection> ::= ref(FlowOutputPort source) ref (FlowOutputPort target)
    
        <FlowConnection> ::= ref(FlowOutputPort source) ref (FlowOutputPort target)
    
        <TemplateParameterValue> ::= <string> | <number> | <bool> | <TemplateParameterValueList>
    
        <TemplateParameterValueList> ::= <TemplateParameterValue>*
    \end{grammar}
    \textbf{Grammatik TODO} Flow-Modell
    \newpage
    \subsection{Typsystem}
    unterstüzt die gleichen Primitiv-Typen wie JSON-Format String, Number und Bool zusätzlich Date und PtiaResponse. Außerdem werden auch gernerische Typen unterstüztz, weil nicht immer von vorneherein der Typ bekannt ist.
    Date ist eine Datumsangabe
    PtiaResponse ist eine Antwort einer Hauptuntersuchungs-Anfrage
    Diese Typen lassen sich an optionalen, Listen oder Objekt-Typen kapseln\\
    \begin{grammar}
        <Type> ::= <TypePrimtive> | <TypeOptional> | <TypeList> | <TypeObject>

        <TypePrimtive> ::= 'String' | 'Number' | 'Bool' | 'Data' | 'PtiaResponse'
        
        <TypeOptional> ::= <Type> '?'
        
        <TypeList> ::= <Type> '[]'
        
        <TypeObject> ::= '\{' (<string key> ':' <Type>)* '\}'

        <TypeGeneric> ::= '\$' <string genericName>

        <TypeReference> ::= ref(Type)
    \end{grammar}
    \textbf{Grammatik TODO} Typ-Defintion mit generischen und Referenz-Typen
    \newpage
    \section{Implementierung}
    Bei der Implementierung muss nicht nur auf des Design des Schleifenkonstrukt geachtet werden, sondern auch auf neue Sachen, welche durch die Implementierung entstanden sind.
    Bei den Schleifendurchläufen wird nicht auf die Ergebnisse des letzten Durchlaufs zugegriffen werden, sondern der Schleifenkörper soll die Entscheidungen auf Grundlage des aktuellen Sensorwertes treffen.
    Das auslesen des aktuellen Sensorwerts ist bereits möglich.
    Aktuell unterstützt die zugrundeliegenede Implementierung noch keine Variablen. Um das zu ändern muss die Grammatik bearbeitet werden-
    \subsection{1. Lösungsansatz}
    %Ausformulierte Notizen. 
    Der Benutzer gibt von vorneherein eine Zahl a an, welche die maximale Anzahl von Schleifendurchläufe beschränkt. Für die Zahl muss dafür folgendes gelten TODO.
    Die Idee des Ansatzes ist es, den Schleifenköper nicht Iterativ oder Rekursiv ausführen, sondern a-mal auszurollen.
    Dafür wird der Schleifenköper und die nachfolgenden Anweisungen a-mal kopiert. Die Schleife wird dadurch nicht dynmasisch ausgeführt, sondern statisch in den Code implementiert. Dadurch entstehen $a+1$ Graphen. Jeder dieser Graphen repräsentiert einen ursprüngliche Iteration. Dabei werden die einzelnen Graphen mit ihren direkten Nachbaran verbunden. 
    Da die aktuell zugrunde liegende Implementierung determenistisch ist und aktuell nur auf die gleiche Eingabe zugegriffen werden kann, muss ein Mechanismus implementiert werden, welcher den aktuellen Sensorwert ausliest und diesen an die nachfolgenden Anweisungen weitergibt. Dieser Vorgang muss für jede neu eingefügte Verbindung wiederolt werden.
    Dieser Ansatz wird auch von Ye et al. im Konferenz-Paper "Loop Unrolling Based on SLP and Register Pressure Awareness" beschrieben.\\
    \resizebox*{!}{10cm}{
    \begin{tikzpicture}[]
        %Graph links
        \node[state, initial text=""](q0){};
        \node[state, rectangle, below = 1cm of q0](q1){Aktion1};
        \node[state, rectangle, below = 1cm of q1](q2){Aktion2};
        \node[state, below = 1cm of q2](q3){Entscheidung};
        \node[state, accepting, rectangle, below = 1cm of q3](q4){Ausgabe};

        \draw(q0) edge[->] (q1);
        \draw(q1) edge[->] (q2);
        \draw(q2) edge[->] (q3);
        \draw(q3) edge[->, bend right] (q1);
        \draw(q3) edge[->] (q4);

        %Graph rechts
        \node[state, initial text="", right = 2cm of q0](q5){};
        \node[state, rectangle, right = 2cm of q1](q6){Aktion1};
        \node[state, rectangle, right = 2cm of q2](q7){Aktion2};
        \node[state, below = 1cm of q7](q8){Entscheidung};
        \node[state, rectangle, accepting, below = 1cm of q8](q9){Ausgabe};

        \node[state, rectangle, right = 2cm of q6](q10){Aktion1};
        \node[state, rectangle, right = 2cm of q7](q11){Aktion2};
        \node[state, below = 1cm of q11](q12){Entscheidung};
        \node[state, rectangle, accepting, below = 1cm of q12](q13){Ausgabe};

        \node[state, rectangle, right = 2cm of q10](q14){Aktion1};
        \node[state, rectangle, right = 2cm of q11](q15){Aktion2};
        \node[state, below = 1cm of q15](q16){Entscheidung};
        \node[state, rectangle, accepting, below = 1cm of q16](q17){Ausgabe};

        \draw(q5) edge[->] (q6);
        \draw(q6) edge[->] (q7);
        \draw(q7) edge[->] (q8);
        \draw(q8) edge[->] (q9);
        \draw(q8) edge[->] (q10);
        
        \draw(q10) edge[->] (q11);
        \draw(q11) edge[->] (q12);
        \draw(q12) edge[->] (q13);
        \draw(q12) edge[->] (q14);

        \draw(q14) edge[->] (q15);
        \draw(q15) edge[->] (q16);
        \draw(q16) edge[->] (q17);


    \end{tikzpicture}
    }
    \\\textbf{Abbildung TODO} Algorithmus Schleifenentfaltung\\
    \\Auf die Vor- und Nachteile der Implementierung wird im Kapitel~\ref{Evaluation} eingegangen.
    \subsection{2. Lösungsansatz}
    Wie auch schon beim 1. Lösungsansatz gibt der Benutzer von vorneherein eine Zahl a an, welche die Anzahl an Schleifendurchläufen beschrnänkt. Für die Zahl a gelten die gleichen Bedingungen wie im 1. Lösungsansatz beschrieben. 
    Zusätzlich wird noch eine Zahl TODO benötigt, welche auch der Benutzer angeben muss. TODO soll dabei die Funktionen eines Grenzwertes übernehmen.
    Bei diesem Ansatz werden mehrere Mittelwerte gebildet und geschaut, wie sich der neu ausgelesene Sensorwert sich im Verhältnis zu den Mittelwerten verhält. Es wird die Differenz zwischen Mittelwert und aktuellen Sensorwert gebildert. Anschließend wird geschaut auf die Differenz größer als TODO ist.
    Die Mittelwerte bilden wir einmal über alle bisherigen Sensorwerte und einmal über die letzten b Sensorwerte. Dadurch haben wir die Mittelwerte für einen kurzen und längeren zeitraum.
    Sollte das der Fall sein, wissen wir das die Sensorwerte sich noch nicht stabilisiert haben und wir können den Vorgang wiederholen. Da wir nicht bereits nachdem ersten stabilisierten Wert aufhören wollen, sondern erst wenn der Wert über einen längeren Zeitraum stabil ist, führen wir folgenden n-Chance-Mechanismus ein:
    \begin{itemize}
        \item Sollte der Grenzwert unterschritten werden, wird der Counter um 1 erhöht.
        \item Sollte der Grenzwert überschritten werden, wird der Counter wieder auf 0 gesetzt.
        \item Sollte der Counter irgendwann n erreichen, wissen wir das sich die Werte stabilisiert haben und wir davon ausgehen können dass das zu erwartende Ergebniss nicht mehr rauskommt.
    \end{itemize}
    %Schluss
    \newpage
    \section{Evaluation}
    \label{Evaluation}
    \subsection{}
    \subsubsection{1. Lösungsansatz}
    +einfach zu implementieren, da wir kein schleifenkonstrukt mehr benötigen.
    +keine Endlosschleife, weil es keine Schleifen gibt
    +keine Zyklen, weil der Ablauf linear ist
    +weniger Sprünge, weil keine for oder while Bedingungen vorhanden sind
    +möglicher Performance gewinn, weil Schleifen-Overhead entfällt
    -größerer Codeumfang, da der eigentliche schleifenkörper a-mal im code implemtniert werden muss 
    -höherer verbraucht an ressourcen zB Speicher mehr code = mehr speicher
    -möglicherweise ineffizient, wenn der faktor zu groß gewählt wird
    -schlechtere Lesbarkeit
    -wenn bereits nach 3 durchlaufen feststeht, dass das gewünschte ergbeniss nicht mehr erreicht werden kann werden trotzdem die restlichen schritte ausgeführt
    \newpage
    \renewcommand{\refname}{}
    \section{Literaturverzeichnis}
    \begin{thebibliography}{9}
        \bibitem{2}Johnston, W., Hanna, J., \& Millar, R. (2004). \emph{Advances in dataflow programming languages}. ACM Computing Surveys, 36(1), 1–34.
        \bibitem{3}Chen, L. (2021). \emph{Iteration vs. Recursion: Two Basic Algorithm Design Methodologies}. SIGACT News, 52(1), 81–86.
        \bibitem{4}Arvind, \& Culler, D. (1986). \emph{Dataflow Architectures}. LCS Technical Memos.
        \bibitem{5}Ambler, A., \& Burnett, M. (1990). \emph{Visual forms of iteration that preserve single assignment}. Journal of Visual Languages \& Computing, 1(2), 159–181.
        \bibitem{6}Mosconi, M., \& Porta, M. (2000). \emph{Iteration constructs in data-flow visual programming languages}. Computer Languages, 26(2), 67–104.
        \bibitem{1}Fan, Z., Li, W., Liu, T., Tang, S., Wang, Z., An, X., Ye, X., \& Fan, D. (2022). \emph{A Loop Optimization Method for Dataflow Architecture}. In 2022 IEEE 24th Int Conf on High Performance Computing \& Communications; 8th Int Conf on Data Science \& Systems; 20th Int Conf on Smart City; 8th Int Conf on Dependability in Sensor, Cloud \& Big Data Systems \& Application (HPCC/DSS/SmartCity/DependSys) (pp. 202–211).
        \bibitem{7}Gévay, G., Soto, J., \& Markl, V. (2021). \emph{Handling Iterations in Distributed Dataflow Systems}. ACM Comput. Surv., 54(9), 199:1–199:38.
        \bibitem{8}Alves, T., Marzulo, L., Kundu, S., \& França, F. (2021). \emph{Concurrency Analysis in Dynamic Dataflow Graphs}. IEEE Transactions on Emerging Topics in Computing, 9(1), 44–54.
        \bibitem{9}Ye, Z., \& Jiao, J. (2024). \emph{Loop Unrolling Based on SLP and Register Pressure Awareness}. In 2024 20th International Conference on Natural Computation, Fuzzy Systems and Knowledge Discovery (ICNC-FSKD) (pp. 1–6).
        \bibitem{10}Lučanin, D., \& Fabek, I. (2011). \emph{A visual programming language for drawing and executing flowcharts}. In 2011 Proceedings of the 34th International Convention MIPRO (pp. 1679–1684).
        \bibitem{11}Davis, A., \& Keller, R. (1982). \emph{Data Flow Program Graphs}. All HMC Faculty Publications and Research.
        \bibitem{21}Boshernitsan, M., \& Downes, M. (2004). \emph{Visual Programming Languages: A Survey}. EECS University of California, Berkeley.
        \bibitem{12}Charntaweekhun, K., \& Wangsiripitak, S. (2006). \emph{Visual Programming using Flowchart}. In 2006 International Symposium on Communications and Information Technologies (pp. 1062–1065).
        \bibitem{13}Burnett, M., Baker, M., Bohus, C., Carlson, P., Yang, S., \& Van Zee, P. (1995). \emph{Scaling up visual programming languages}. Computer, 28(3), 45–54.
        \bibitem{14}Kurihara, A., Sasaki, A., Wakita, K., \& Hosobe, H. (2015). \emph{A Programming Environment for Visual Block-Based Domain-Specific Languages}. Procedia Computer Science, 62, 287–296.
        \bibitem{15}Hils, D. (1992). \emph{Visual languages and computing survey: Data flow visual programming languages}. Journal of Visual Languages \& Computing, 3(1), 69–101.
        \bibitem{19}Sousa, T. (2012). \emph{Dataﬂow Programming Concept, Languages and Applications}. Doctoral Symposium on Informatics Engineering, 7.
        \bibitem{18}Van Deursen, A., Klint, P., \& Visser, J. (2000). \emph{Domain-specific languages: an annotated bibliography}. ACM SIGPLAN Notices, 35(6), 26–36.
        \bibitem{16}Roy, G., Kelso, J., \& Standing, C. (1998). \emph{Towards a visual programming environment for software development}. In Proceedings. 1998 International Conference Software Engineering: Education and Practice (Cat. No.98EX220) (pp. 381–388). IEEE Comput. Soc.
        \bibitem{20}Weintrop, D. (2019). \emph{Block-based programming in computer science education}. Communications of the ACM, 62(8), 22–25.
        \bibitem{22}Gumm, H.P., \& Sommer, M. (2016). \emph{Band 1 Programmierung, Algorithmen und Datenstrukturen}. De Gruyter Oldenbourg.
    \end{thebibliography}
\end{document}    