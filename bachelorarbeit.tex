\documentclass{article}
\usepackage{syntax}
\usepackage{tikz}
\usepackage{struktex}
\usepackage{fancyvrb}
\usetikzlibrary{automata, positioning}

\begin{document}
    %Fachlexikon für definition verwenden
    \newpage
    \tableofcontents
    %Einleitung
    \newpage
    \section{Einleitung}
    In diesem Kapitel wird in kürze erläutert was die Motivation und Aufgabe der Bachelorarbeit ist.
    Im Anschluss daran werden sich andere Systeme angeschaut und erklärt, wie diese das Problem lösen.
    Anschließend wird ein kurzen Überblick über die kommenden Kapitel gegeben.
    \subsection{Aufgabe und Motivation}
    Prüfungen, die mithilfe grafischer Editoren modelliert werden, müssen in vielen Fällen eine Vielzahl von wiederkehrenden Aufgaben abbilden. 
    Diese Wiederholungen können bei der aktuellen Implementierung nur schwer abgebildet werden, da Schleifen als Konstrukte nicht zur Verfügung stehen. 
    Stattdessen müssen zu wiederholende Abläufe mehrfach und explizit modelliert werden. 
    Dies führt zu Redundanz, erhöht die Komplexität der Modelle und erschwert deren Wartbarkeit.\\
    \\
    In klassischen Programmiersprachen wird das Problem der Wiederholung durch die Verwendung von Schleifenkonstrukten gelöst, welche eine kompakte und dynamische Modellierung ermöglichen. 
    In grafischen Editoren ohne native Unterstützung von Schleifen ist es hingegen notwendig, Prüfungen statisch und mehrfach abzubilden. 
    Eine pragmatische Lösung besteht darin, Prüfungen mehrfach auszuführen oder die zu wiederholenden Abläufe manuell zu duplizieren und diese mit bedingten Verzweigungen zu Verbinden. 
    Dies ist jedoch oft nicht praktikabel, da Prüfungen häufig an variable oder unvorhersehbare Bedingungen angepasst werden müssen.
    Die einzige Möglichkeit, um dynamische Daten während einer Prüfung effizient und wartbar zu bearbeiten, besteht darin, ein Schleifenkonstrukt in das bestehende System zu integrieren. 
    Daraus ergibt sich ein klares Interesse, entsprechende Erweiterungen zu konzipieren und zu implementieren.
    \\
    \\
    Im laufe der Bachelorarbeit sollen mehrere Möglichkeiten konzepiert und implementiert werden, welche es ermöglichen sollen dynamsichen Daten innerhalb einer Prüfung zu verarbeiten. 
    Dafür muss im Vorfeld das zugrunde liegende System analysiert und bearbeitet werden, sodass Zyklen vom System verarbeitet werden können.
    Nach der Implementierung sollen diese Bewertet werden.
    \subsection{Aufbau der Arbeit}
    Die vorliegenede Arbeit setzt sich aus TODO nachfolgenden Kapiteln zusammen. 
    Im zweiten Kapitel TODO
    Anschließend daran wird im dritten Kapitel TODO
    Darauf aufbauen wird im vierten und fünften Kapitel TODO
    Der Fokus im letzten Kapitel liegt auf TODO 
    \newpage
    \section{Terminologie}
    Der Fokus dieses Kapitels liegt auf der Definition zentraler Fachbegriffe um dadurch einen einheitlichen terminologischen Rahmen zu schaffen. 
    Das Ziel dieses Kapitels ist es die Verständlichkeit der nachfolgenden Kapitel zu erhöhen und die theoretischen Grundlagen der Arbeit zu festigen.\\
    \\
    \textbf{Schleifen}\\
    \\
    Eine Schleife ist eine Kontrollstruktur, die einen Programm-Abschnitt mehrmals ausführt. \cite{22}
    Häufig ist diese dabei die zeitintensivste Komponente eines Programms, da ihre die Ausführung sehr viel Zeit in anspruch nehmen kann. \cite{1}
    Der Algrorithmus dieser Kontrollstruktur kann dabei iterativ oder rekursiv implementiert werden. Ersteres wiederholt die Schleife mehrmals. Hingegen die Rekursion sich mehrmals selbst aufruft. \cite{3}
    Zur umsetzung verwendet die Iteration einen Akkumulativenansatz. Dabei wird das Problem schrittweise gelöst. Der Prozess wird solange wiederholt bis eine vordefinierte (Abbruch-)Bedingung erfüllt ist. \cite{3}
    Im gegensatz zur Iteration verwendet die Rekursion keinen Akkumulativenansatz, sondern zerlegt das Problam in mehrere (Teil-)Probleme. Für die Teilprobleme werden dann einzelne Lösungen erarbeitet, welche im Anschluss wieder kombiniert werden um das eigentliche Problem zu lösen. \cite{3}
    Laut Chen L. spiegelt die Iteration das menschliche Denken wieder, weshalb sie sich besonders für lineare Probleme eignet. 
    Die Rekursion hingegen ist für Probleme geeignet, welche Zwischenergebnisse oder Teillösungen benötigen. \cite{3}
    Eine Schleife kann dabei in zeitabhängig oder horizontal unterteilt werden. Bei einer zeitabhängigen Schleife hängt das Ergebnis des aktuellen Schleifendurchlaufs vom Ergebnis des vorherigen Schleifendurchlaufs ab. Andererseits sind die Ergebnisse der Schleifendurchläufe bei der horizontalen Schleife unabhängig voneinander. \cite{5}\\
    \\
    \textbf{Domain Specific Language}\\
    \\
    Bei einer domänenspezifische Sprache (DSL) handelt es sich um eine Programmiersprache, die mit dem Ziel entwickelt wurden ist, spezifische Aufgabenstellungen innerhalb eines begrenzten Anwendungskontexts (Domaine) besonders effektiv zu lösen. \cite{18}
    DSLs bilden das Gegenstück zu General-Purpose Languages (GPL) wie Java, C++ oder Python. \cite{14}
    Anders als bei GPLs verfügen DSLs oftmals über eine reduzierte Syntax, die ausschließlich für den jeweilige Domaine relevant ist. Teilweise wird diese durch eine GPL ergänzt. \cite{18}
    Es wird zwischen externen und internen DSLs unterschieden. Externe DSLs haben ihre eigene Syntax. Dadurch kann eine größere flexibilität geschaffen werden, aber zeitglich ist der Aufwand für den Entwickler sehr hoch, weil alle relevanten Tools selbst implementieren muss. Außerdem braucht der Benutzer länger Zeit um die Syntax zu lernen. \cite{7}
    Zur Laufzeit wird die externe DSLs dann in eine GPL übersetzt. \cite{14}
    Interne DSLs verwenden die Syntax einer GPL und kann über eine Programmierschnittstelle oder Bibliothek aufgerufen werden. \cite{14}
    Die Vorteile von DLSs liegen in ihrer strukturellen Klarheit und Spezialisierung. Dem gegenüber stehen die Nachteile eines hohen Initialaufwands sowie einer begrenzten Flexibilität und Verfügbarkeit. \cite{18}\\ 
    \\
    \textbf{Visual Programming Language}\\
    \\
    Visuelle Sprachen (VL) sind Sprachen, bei denen die Informationsdarstellung primär über grafische Elemente und nicht über textuelle Komponenten erfolgt. \cite{5}
    Dabei werden hauptsächlich grafische Tools und visuelle Metaphoren verwendet. Bilder eignen sich besonders gut zum Programmieren, weil Bilder ausdruckstärker als Worte sind und haben einen höheren Wiedererkennungswert. Durch die eingeschränkte Syntax sind VLs nicht so flexibel und ausdruckstar wie Text-basierte Sprachen. \cite{16}\\
    \\
    Eine spezielle Form visueller Sprachen stellen die visuellen Programmiersprachen (VPL) dar, bei denen grafische Darstellungen gezielt für die Erstellung von Programmen genutzt werden.    
    Das Hauptziel VPL besteht in der Verbesserung der Darstellung der Programmierlogik sowie in der Erleichterung des Verständnisses von Programmabläufen. \cite{13}
    Dadurch soll der Fokus des Programmierens stärker auf konzeptuelle statt symtaktische Aspekte verlagert werden. Die syntaktischen Aspekte werden von der Entwicklungsumgebung übernommen. \cite{10}
    Die Umsetzung von Programmen erfolgt durch die Möglichkeit, Programme in Form von Flussdiagrammen zu erstellen, die unmittelbar vom System interpretiert und ausgeführt werden können. \cite{12}
    Nach Charntaweekhun bieten Flussdiagramme einen didaktischen Vorteil, da sie es insbesondere Programmieranfängern ermöglichen, komplexe Abläufe visuell zu erfassen und zu strukturieren. \cite{12}
    Im Gegensatz zu GPLs, die eine freie textuelle Eingabe haben, verwenden VPLs nur eine begrenzte Menge an vordefinierten grafischen Elemente. Infolgedessen wird die Lesbarkeit erhöht und syntaktische Fehler reduziert.\cite{10}
    Die Klassifikation visueller Programmiersprachen unterscheidet zwischen imperativen und deklarativen Modellen. Ersteres gibt die exakte Reihenfolge der Operationen vor, während letzteres lediglich Datenabhänigkgieten spezifiziert und die Ausführungsreihenfolge dem System überlasst.\cite{21}
    Die stärken von VPLs liegen in ihrer Einfachheit, visuelle Darstellbarkeit, Transparenz und Interaktivität.\cite{13}
    Visuelle Programmiersprachen (VPLs) basieren überwiegend auf einem datenflussgesteuerten Modell, bei dem die Strukturierung von Programmen durch den Austausch von Informationen zwischen Operatoren erfolgt. \cite{6}
    Zusammengefasst kann man sagen, dass VPLs die Vorteile von Flussdiagrammen und nicht die Nachteile der klassischen Programmierung kombiniert. \cite{13}\\
    \\
    \textbf{Datenfluss-basierte Sprachen}\\
    \\
    %Punkte von Jonston et. al erklären  und zyklisch/azyklisch
    Als Datenfluss-basierte Sprache (DL) wird eine Programmiersprache verstanden, bei der die Daten zwischen Funktionnen weitergeleitet werden. Die Programme werden dabei als Graphen dargestellt. \cite{11}
    Der zugrunde liegende Programmgraph ist als gerichteter Graph (DG) definiert, wobei Funktionen als Knoten dargestellt werden, die durch gerichtete Kanten miteinander verbunden sind. Die Richtung der Kanten spiegelt die Datenabhängigkeiten wieder.\cite{2}
    Datenflussgraphen lassen sich hinsichtlich ihrer Granularität in feinkörnig und grobkörnig unterteilen. In einem feinkörnigen Graphen führt jeder Knoten extakt eine Instruktions aus, während grobkörnige Graphen mehrere Instruktionen pro Knoten ausführen können.\cite{1}
    Neben der Granularität lässt sich ein Datenflussgraph auch in Zyklenstrukturen unterteilen. 
    Dabei wird zwischen zyklisch und azyklisch unterschieden. \cite{8} %TODO begriffe kurz erklären
    DLs sind überwiegend funktional geprägt, aber können auch text-basiert sein. \cite{2}
    Der Vorteil einer DLs ist, dass diese durch einen Graphen dargestellt werden können \cite{11} und dadurch die Programme einfach zur verstehen sind. \cite{6}
    Für komplexe Programmen kann eine reine Graphendarstellung schnell unübersichtlich werden. Zur Struktuierung komplexer Programme werden Mikrofunktionen eingesetzt, bei denen einzelne Knoten auf untergeordnete Teilgraphen verweisen. Dadurch lassen dann auch rekursive Abläufe modellieren. \cite{11}    
    DLs führen Instruktionen nicht in einer festen Sequenz aus. Dadurch können unabhängig voneinander ausführbare Instruktion parallel verarbeitet werden. \cite{1}
    Diese Form der Ausführung ermöglicht eine Effizienzsteigerung, da der Ablauf nicht mehr durch einen zentralen Programmzähler gesteuert wird. \cite{2}

    Johnston et. al beschreiben in ihrer Wissenschaftlichenarbeit eine Menge von Eigenschaften. So sollen DLs frei von Seiteneffekten sein, den Lokalitätsprinzip folgen und keine Variablen überschreiben.\cite{2}\\
    \\
    Eine Computerarchitketur, die auf DLs basiert, wird Datenfluss-basiertea System (DFA) genannt.
    DFS wurde eingeführt um den Flaschenhals der von-Neumann-Architektur zu vermeiden. \cite{8} %TODO überprüfen ob zittat wirklich von 8 kommt

    Je nach Implementierung kann nur lokaler Speicher verwendet werden. \cite{8}
    Bei den Ergebnissen erfolgt eine direkte Datenweitergabe zwischen Funktionen, wobei Transformation und Filterung integraler Bestandteil der Verarbeitung sind. \cite{15}

    DFA-Systeme zeichnen sich durch eine hohe Effizienz, flexible Strukturen und leistungsstarke Ausführungsmechanismen aus. \cite{1}
    Ein weiterer Vorteil besteht im möglichen Paralellismus. Da bei fehlender Datenabhängigkeit mehrere Insturktionen gleichzeitig ausgeführt werden können. \cite{1}
    Innerhalb von DFA-System wird zwischen daten- und bedarfgetriebener Ausführung unterschieden. Ersteres führt die Funktionen aus, sobald alle benötigten Operanden vorhanden sind und ein Signal vorliegt. Hingegen bei der bedarfgetriebenen Ausführung die Funktion bereits ausgeführt wird, sobald die Operanden vorhanden sind. \cite{2}
    Aus dem Grund kann die datengesteuerte Ausführung als Spezialfall einer bedarfsgesteuerten Ausführung angesehen werden, bei der ein Bedarf an allen Ergebnissen von vorneherein besteht. \cite{11}
    %TODO kurzer vergleich zu von neumann
    %BBS imperativen Programmierablauf, Datenfluss/Kontrollfluss
    %lazy evaluation im zusammenhang mit bedarfgesteuert erklären
    \newpage
    \section{Systemanalyse}
    In diesem Kapitel wird das System hinsichtlich seiner strukturellen und funktionalen Eigenschaften analysiert. 
    Zunächst wird die zugrundeliegende Grammatik betrachtet, woraufhin die Ausführungslogik beschrieben wird. Abschließend werden die problematischen Stellen im Hinblick auf die geplante Erweiterung analysiert.
    Ziel dieses Kapitels ist es, diese problematischen Stellen zu erfassen und aufzubereiten, um eine Grundlage für die folgenden Kapitel zu schaffen.\\
    \subsection{Grammatik}
    %Die zugrundeliegende Grammatik basiert auf der Backus-Naur-Form (BNF) Notation. Der Aufbau einer BNF wird anhand der Grammatik~\ref{BNF} erklärt
    %<symbol> sind nichtterminale
    %::= bedeutet dass symbol durch _expression_ ersetzt wird
    %_expression_ ist eine sequenze von nichterminalen und terminale
    %Kleene-Stern * wiederholung
    %Alternation \textbar  oder
    %Sequenz erlaubt auch Klammern um die Reihenfolge der Regel zu definieren
    %Softwareprüfung lääst sich visuall von zwei seiten betrachen. 
    %\begin{grammar}
    %    <symbol> ::= _expression_
    %\end{grammar}
    %\textbf{Grammatik TODO} Backus-Naur-Form\\\\\\
    \label{BNF}
    Die Grammatik der domainspezifischen Sprache lässt sich Formal in drei Ebenen unterteilen. 
    Die oberste Ebene ist die Prüfungslogik, die mittlerste Ebene ist die Datenverarbeitung und die letzte Ebene ist das Typsystem. \cite{99}
    Ersteres beschreibt die benötigten Aktionen und Entscheidungen für eine Prüfung. \cite{99}
    Hingegen die Datenverarbeitung für die Definition von Datentranformationen zuständig ist und eine von mehreren Aktionstypen darstellt. \cite{99}
    Im gegensatz dazu kümmert sich das Typsystem um die statische Analyse der Ausführbarkeit der vorangegangen Ebenen. \cite{99}
    %Grammatik lässt sich in 3 Ebenenunterteilen Prüfungslogik, Datenverarbeitung und Typsystem
    %Prüfungslogik führt Entscheidung im Prüfungsablauf aus und bestimmt die Reihenfolge der Aktionen. außerdem datenerfassung
    %Datenverarbeitung ist für die Datentranformation auswertung zustädnig. Also Funktionen, welche keine Nebeneffekte besitzen, weil sie unabhängig von der restoichen Softwareprüfung stattfinden.
    %Typsystem ermöglicht die statische analyse der ausführbarkeit
    %Softwareprüfung lääst sich visuall von zwei seiten betrachen. 
    %Einmal als Datenflussgraphen, indem Teil-Funktionen als Blöcke dargestellt werden und Funktionsparamter/Ergebnisse als Ports.
    %Einmal als Aktivitätsdiagramm, in dem nur Startzustand, Endzustände, Aktions- und Entscheidungsblöcke dargestellt.
    %Die folgende Zusammenfassung basiert auf der unveröffentlichen Arbeit von Westermann et al.
    
    \subsubsection{Prüfungslogik}
    Die in Abbildung TODO abgebildeten Regeln beschreib das Aktivitätsmodell, die der Prüfungslogik entspricht. \cite{99}
    Zentral ist dabei die Regel \textit{ActivityModel}, welche festlegt, dass ein Aktivitätsmodell aus mehreren Aktivitäten und Verbindungen besteht.
    Die Verbindung referenziert dabei zwei Aktivitäten und hat auch eine Bezeichnung, die als TODO.
    Die Regel \textit{Activity} beschreibt die möglichen Aktivitäten innerhalb des Aktivitätsmodells. Dabei kann eine Aktivität entweder eine Startmarkierung, ein Vergleich, eine Aktion oder ein Label sein.
    
    Ein Vergleich kann entweder ein Binärvergleich oder ein Validierungsvergleich sein.
    Ersteres besteht dabei aus einer Referenz auf ein Flowtemplate, das eine Datenverarbetung ist, gefolgt von einem Operator und zwei Argumenten. Als Operatoren stehen $=$ und $\neq$ sowie Relationale Operatoren zur Verfügung.
    Der Validierungsvergleich hingegen besteht nur aus einer Menge von TODO.

    Bei den Aktionen wird zwischen Hauptunsersuchungs-Adpater Anfragen, lesen von JSON-Dateien und Ausführung einer Datenverarbeitung unterschieden.
    Der Aufbau einer Hauptuntersuchungs-Adapter Anfrage umfasst dabei den Namen der auszuführenden Anfrage, eine Beschreibung, eine Liste mit anzusprechenden Systemen im Fahrzeug und eine maximale Ausführungsdauer.
    Im Gegensatz dazu setzt sich das lesen von JSON-Dateien aus dem Datentyp der zu lesenden Datei und einer URI zu der Datenquelle zusammen.
    Die letzte Aktionform, die Ausführung einer Datenverarbeitung, besteht aus einem Verweis auf einem FlowTemplate, gefolgt von einer Beschreibung der Eingaben, die für die Datenverarbeitung erforderlich sind, sowie einer Transformation, die beschreibt wie das Ergebnis weiterverwendet werden soll.    
    Die Beschreibung der Eingaben setzt sich aus den Symbolen ActivityPortValue und TemplateParameterValue zusammen.

    Die Struktur eines Label wird durch eine Kombination aus einer Beschriftung, einer Farbe und einem Verweis auf eine Aktion beschrieben.\\
    %Die Regel $<ActivityModel>$ beschreibt die Grundstruktur des Aktivitätsmodell und setzt sich aus $<Acitvity>$ und $<ActivityConnection>$ zusammen. 
    %$<Acitvity>$ sind dabei Aktivitäten und kann entweder eine Startmakierung ($<ActivityStart>$), ein Vergleich ($<ActivityCondition>$), eine Aktion ($<ActivityAction>$) oder ein Label ($<ActivityDisplay>$) sein.
    %$<ActivityConnection>$ hingegen definiert, welche Aktivtäten miteinander verbunden sind und setzt sich aus zwei Aktivitäten (ref(Acitvity source) und ref(Acitvity target)) und einer Beschriftung für die Kante ($<string label>$)
    %Eine Aktion kann dabei eine der folgenden Aktionen sein:
    %\begin{itemize}
    %    \item Senden von Hauptuntersuchungs-Adatper-Anfragen (A1) $<ActivityPitaBuildInforRequest>$
    %    \item Lesen einer JSON Datei (A2) $<ActivityLoadExternalData>$
    %    \item Ausführung einer Datenverarbeitung (A3) $<ActivityFlowCall>$
    %\end{itemize}
    %$<ActivityFlowCall>$ setzt sich aus einem Flow-Template (ref(FlowTemplate)), mehreren Eingaben ($<ActivityPortValue>$ und $<TemplateParameterValue>$) und mehreren Transformationen ($<ValueTranformation>$).
    %Die Transformation beschreibt dabei wie das Ergebnis der Datenverarbeitung weiter genutzt werden soll.
    %Auf die Bedetung des Flow-Templates und der TemplateParameterValue wird im verlaufe des Kapitel eingegangen
    %$<FlowPortValue>$ setzt sich aus einer Reihe von primtiven Typen ($<FlowPortValue>$) oder einem verweis auf einer Aktion mit einer Transformation ($<ActivityPortValue>$) zusammen.
    %$<ActivityPitaBuildInforRequest>$ uns $<ActivityLoadExternalData>$ setzen sich nur aus Eingaben vom primtiven Typ zusammen, welche für die Ausführung des zwecks notwendig sind zusammen.
    %Der Vergleich kann etweder ein Binärvergleich $<ActivityBinaryCondition>$ oder ein Validierungsvergleich $<ActivityValidityCondition>$ sein.
    %Der Binärvergleich setzt sich dabei aus einem Flow-Template, einem Operator ($〈ActivityBinaryConditionOperator〉$) und zwei Eingaben ($<ActivityPortValue right>$ und $<ActivityPortValue left>$) zusammen.
    %Das Label kann sich dabei aus mehreren Textfeldern ($〈ActivityDisplayField〉$) zusammen. Ein Textfeld besteht dabei aus einer Beschriftung ($〈string label〉$), einer Farbe ($〈string color〉$) und einem Verweis auf eine Aktion (ref(ActivityAction))

    %Das Aktivitätsmodell  $<ActivityModel>$ besteht aus einer Reihe von Aktivitäten $<Activity>$.
    %Aktivitäten können dabei entweder eine Startmarkierung, eine Aktivitätsaktion, einem Vergleich oder visualles Label sein.
    %Die Startmarkierung muss pro Prüfungslogik genau einmal vorkommen.
    %$<ValueTransformation>$ beschreibt wie das Ergebnis der Datenverarbeitung weiter genutzt werden sollen
    %Ein vergleich kann dabei entweder eine Binärentscheidung oder eine Validierungsentscheidung sein.   
    %Die Validierungsentscheidung $<ActivityValidityCondition>$ nimmt als Eingabe einen Wert und überprüft ob diese Werte vorhanden sind.
    %Die Binärentscheidung $<ActivityBinaryCondition>$ nimmt als Parameter zweite Werte, einen Vergleichoperatur und eine referenz zu einer Funtkion. Dabei werden beide Werte als Eingabe für die referenzierte Funktion verwendet.
    %Als Vergleichoperatoren stehen $=$ und $\neq$ sowie Relationale Operatoren zur verfügung.
    %Eine Aktivitätaktion <ActivityAction> kann dabei einer der folgenden Aktionen ausführen:
    %Bevor das Ergbeniss aus der vorherigen Aktionsaktivität verwendet wird, kann eine Transformation auf dieses Ergebniss angewendet werden.

    %A1 nimmt als Parameter den Namen der auszuführenden Anfrage, eine Beschreibung für den debugger, eine Liste von anzusprechnenden System im Fahrzeig und die maximale Zeitdrauer einer Anfrage.
    %A2 nimmt als Eingabe den Typ der zu ladenenden Datei und die dazugehörige URI.
    %A3
    \begin{grammar}
        <ActivityModel> ::= <Activity>* <ActivityConnection>

        <Activity> ::= <ActivityStart>
        | <ActivityAction>
        | <ActivityCondition>
        | <ActivityDisplay>

        <ActivityConnection> ::= ref(Activity source) <string label> ref(Activity target)

        <ActivityStart> ::= $\epsilon$

        <ActivityAction> ::= <ActivityFlowCall>
        | <ActivityPitaBuildInforRequest>
        | <ActivityLoadExternalData>

        <ActivityFlowCall> ::= ref(FlowTemplate) <ActivityPortValue>* <TemplateParameterValue>* <ValueTransformation>*

        <ActivityPitaBuildInforRequest> ::= <string abdFilename> <string requestAlias> <string expectedSystems>* <number timeout>

        <ActivityLoadExternalData> ::= <Type dataType> <string dataSource>

        <ActivityPortValue> ::= <FlowPortValue>
        | <ActivityPortRefernce>

        <FlowPortValue> ::= <string>
        | <number>
        | <bool>
        | <date>
        | <FlowPortValue>*

        <ActivityPortRefernce> ::= ref(ActivityAction) (ValueTransformation)*

        <ValueTransformation> ::= <string objectReference>
        | <number listIndex>

        <ActivityCondition> ::= <ActivityBinaryCondition>
        | <ActivityValidityCondition>

        <ActivityBinaryCondition> ::= ref(FlowTemplate) <ActivityBinaryConditionOperator> <ActivityPortValue left> <ActivityPortValue right>

        <ActivityValidityCondition> ::= <ActivityPortValue>*

        <ActivityBinaryCondition> ::= '='
        | '$\neq$' 
        | '\textless' 
        | '$\leq$' 
        | '\textgreater' 
        | '$\geq$'

        <ActivityDisplay> ::= <ActivityDisplayField>*

        <ActivityDisplayField> ::= <string label> <string color> ref(ActivityAction)
    \end{grammar}
    \textbf{Grammatik TODO} Aktivitätsmodell
    \newpage
    \subsubsection{Datenverarbeitungs}
    %Eingabe <FlowInputPort> und Ausgabe $<FlowOutputPort>$
    %Funktionen höherer Ordnung $<FlowLamda>$
    %Eine Funktion höher Ordnung besteht aus zustzälciehn Eingabe- und Ausgabeports
    %Eingabe- und Ausgabeports nehmen als Parameter einen Namen des Ports, den Typ und ob Fehlererlaub ist.

    %Ein Funktions Template $<FlowTemplate>$ besteht aus einer Funktion $Flow$ und belieg vielen Parametern $<TemplateParameter>$
    %Die Parameter generieren Port- und Lambda-Defintion
    %Funktionen welche vom Autorensystem $<LibraryFlow>$ und selbst definierte Funktionen $<FlowModel>$

    %Ein Flow-Modell ist ein DAG bei dem mehrere Funktionen mitienander verbunden werden. Einzelne Funktionen werden Nodes $<FlowNode>$ genannt.
    %Das Flow-Modell wird durch eine $<FlowInstance>$, Reihe von Funktionen und Verbidnugen definiert.
    %Die Funktion kann dabei eine Eingabe <$FlowNodeInput>$, eine Ausgabe $<FlowNodeOutput>$, einer Lambda Referenz $<FlowNodeLambda>$ oder eine Funtkions Referenz $FlowNodeFlowCall$
    %Konstante Werte $FlowPortValue$
    %TODO erklären was ist lamba?
    %Die Flow-Instanz ($〈FlowInstance〉$) kann als Funktion interpretiert werden und bildet eine oder mehrere Eingaben ($〈FlowOutputPort lambdaArguments〉$) auf eine oder mehrere Ausgaben ($〈FlowOutputPort  lambdaArguments〉$) ab.
    %Zusätzlich kann die Flow-Instanz aus einer oder mehreren Lamda-Definitionen ($〈FlowLamda〉$) beinhalten. Eine Lamda-Definition hat zusätzliche Eingaben und Ausgaben.
    %Die Ein- und Ausgaben bestehen dabei einem Namen  ($〈string name〉$) , gefolgt vom Typ  ($〈Typ〉$)  und einem boolean  ($〈bool acceptsError〉$) , welcher angibt ob Fehler akzeptiert werden oder nicht.\\
    Die in Abbildung TODO dargestellten Regeln definieren die Struktur einer Flow-Instanz. Dabei kann eine Flow-Instanz als konkreten Aufruf einer Funktion interpretiert werden. 
    Dabei legt Regel \textit{FlowInstance} fest, dass eine Flow-Instanz aus mehreren Eingabe- und Ausgabeports sowie einer Menge von Funktionen höherer Ordnung besteht.
    Der Aufbau einer Funktion höherer Ordnung umfasst wiederum zusätzliche Eingabe- und Ausgabeports.
    Ein Port besteht aus einem Namen, gefolgt vom Datentyp des Ports und einem Wahrheitswert der Angibt ob an diesem Port Fehler erlaubt sind.\\
    \begin{grammar}
        <FlowInstance> ::= <FlowOutputPort lambdaArguments>* <FlowInputPort lambdaArguments>* <FlowLambda>*
        
        <FlowLambda> ::= <FlowOutputPort lambdaArguments>* <FlowInputPort lambdaArguments>*

        <FlowInputPort> ::= <string name> <Type> <bool acceptsError>

        <FlowOutputPort> ::= <string name> <Type> <bool producesError>
    \end{grammar}
    \textbf{Grammatik TODO} Flow-Instanz\\
    \\
    %Ein Flow-Template ($〈FlowTemplate〉$) kann als abstrakte Oberklasse angesehen werden und besteht dabei aus einer Funktion ($〈Flow〉$) gefolgt von keiner oder mehreren Template-Parametern ($〈TemplateParameter〉$), welche Port- und Lambda-Definitionen generien können.
    %Eine Funktion kann dabei eine vom System bereitgestellte ($〈LibraryFlow〉$) oder eine vom Benutzer selbst definierte ($〈FlowModel〉$) sein.\\
    Ein Flowtemplate wird durch die in Abbildung TODO spezifierten Regeln beschrieben.
    Das FlowTemplate wird dabei durch eine Funktion \textit{Flow} und eine Menge von TemplateParametern definiert. 
    Bei den TemplateParameter wird zwischen einer Zeichenkette, Zahlen oder einem Wahrheitswert unterschieden. 
    Diese Parameter beeinflussen die automatische Generierung der Port-Struktur sowie der internen Verarbeitungslogik eines Flows. \cite{99}
    Die Funktionen lassen sich in vordefinierte \textit{LibraryFlow} und eigene erstellten Funktionen \textit{FlowModel} unterteilen.\\
    \begin{grammar}
        <FlowTemplate> ::= <Flow> <TemplateParameter>*

        <Flow> ::= <LibraryFlow> | <FlowModel>
        
        <LibraryFlow> ::= $\epsilon$

        <TemplateParameter> ::= 'String' | 'Number' | 'Bool' | <TemplateParameterList>
        
        <TemplateParameterList> ::= <TemplateParameter>
    \end{grammar}
    \textbf{Grammatik TODO} Flow-Template\\
    \\
    %Die vom System bereitgestellte Funktionen lassen sich dabei in eine von sieben Kategorien unterteilen: Hauptuntersuchungs-Adapter-Antworten, Zeichenkettenverarbeitung, Datum, Vergleichoperatoren, Konverter, Operatoren und Listenverarbeitung.\\\\
    %Das Flow-Model ($〈FlowModel〉$) ist, wie bereits erwähnt, die vom Benutzer selbst definierten Funktionen und besteht aus einer Flow-Instanz, gefolgt von mehreren möglichen Funktionen ($〈FlowNode〉$) und Verbindungen ($〈FlowConnection〉$).
    %Flow-Instanz bestimmt die Ein- und Ausgaben des Flow-Models.
    %kann dabei eine $〈FlowNodeOutput〉$, $〈FlowNodeInput〉$, $〈FlowNodeLambda〉$ oder ein $〈FlowNodeFlowCall〉$ sein.
    %$〈FlowNodeInput〉$ besteht aus einem Verweis an einem Verweis an einer Portdefinition, gefolgt von $〈FlowPortValue〉$. Hingegen $〈FlowNodeOutput〉$ nur aus einer Portdefinition besteht.
    %Die $〈FlowConnection〉$ wird durch zwei Verweise definiert.
    %$〈FlowPortValue〉$ bietet dabei die Möglichekit konstante Werte an die Eingabeports anzulegen.
    Die Regeln des FlowModel sind in Abbildung TODO formal dargestellt. Das FlowModel entspricht dabei der Datenverarbeitung. \cite{99}
    Durch die Regel \textit{FlowModel} wird bestimmt, dass ein FlowModel aus einer FlowInstance, einer Auflistung alle genutzen Flow-Node und definition der Verbindungen zwischen den Eingabe- und Ausgabeports.
    Bei den Flow-Node wird zwischen verweis auf Eingabeports, verweis auf Lambda-Funktionen, verweis auf Funktion mit Auflistung von Parametern oder verweis auf Ausgabeports unterschieden.
    Bis auf das letztere haben alle Flow-Node die Möglichkeit ihre Eingabeports durch konstante Werte zu spezifizieren.\\
    \begin{grammar}
        <FlowModel> ::= <FlowInstance> <FlowNode>* <FlowConnection>*

        <FlowNode> ::= <FlowNodeOutput> | <FlowNodeInput> | <FlowNodeLambda> | <FlowNodeFlowCall>
       
        <FlowNodeOutput> ::= ref(FlowOutputPort)

        <FlowNodeInput> ::= ref(FlowInputPort) <FlowPortValue>

        <FlowNodeLambda> ::= ref(FlowLambda) <FlowPortValue>*

        <FlowNodeFlowCall> ::= ref(FlowTemplate) <FlowPortValue>* <TemplateParameterValue>*
    
        <FlowConnection> ::= ref(FlowOutputPort source) ref(FlowOutputPort target)
    
        <TemplateParameterValue> ::= <string> | <number> | <bool> | <TemplateParameterValueList>
    
        <TemplateParameterValueList> ::= <TemplateParameterValue>*
    \end{grammar}
    \textbf{Grammatik TODO} Flow-Modell
    \subsubsection{Typsystem}
    In Abbildung TODO werden die Regeln des Typsystem dargestellt.
    Das Typsystem unterstützt Primitive- und Generische-Datentypen, welche an einen Optional-Typen, Listen-Typen oder Objekt-Typen gekapselt werden können.
    Als Primtiven-DatenTypen stehen String, Number und Bool zur Auswahl. Zusätzlich noch Data und PtiaResponse. 
    Ersteres ist eine Datumsanagbe. Hingegen PtiaResponse die Antwort von einem Hauptunsersuchungs-Anfrage ist.\\
    \begin{grammar}
        <Type> ::= <TypePrimtive> | <TypeOptional> | <TypeList> | <TypeObject>

        <TypePrimtive> ::= 'String' | 'Number' | 'Bool' | 'Data' | 'PtiaResponse'
        
        <TypeOptional> ::= <Type> '?'
        
        <TypeList> ::= <Type> '[]'
        
        <TypeObject> ::= '\{' (<string key> ':' <Type>)* '\}'

        <TypeGeneric> ::= '\$' <string genericName>

        <TypeReference> ::= ref(Type)
    \end{grammar}
    \textbf{Grammatik TODO} Typ-Defintion mit generischen und Referenz-Typen
    \subsection{Ausführung}
    Im folgenden Abschnitt schauen wir uns an, wie die einzelnen Ebenen ausgeführt werden.
    Die folgende Zusammenfassung basiert auf der unveröffentlichen Arbeit von Westermann et al.\\\\
    Die Prüfungslogik.\\
    \\
    \textbf{Prüfungslogik}\\
    \\
    Die Prüfungslogik stellt die oberste Ebene einer Prüfung dar und wird als Kontrollfluss modelliert.
    Als Startpunkt jeder Prüfung fungiert die Startaktivität, die pro Prüfung nur einmal vorkommt.
    Die Reihenfolge der auszuführenden Aktivitäten wird durch die grade ausgeführte Aktivitäte vorgegeben, da jede Aktivität das Label der zu folgende Kante zurückgibt.
    Eine Prüfung ist beendet, sobald die auszuführende Aktivität kein Label mehr zurückgibt.\\
    \\
    Ein wichtiger Bestandteil der Prüfungslogik ist der Referenzstack. Der Referenzspeicher dient als Speicher für die Ergebnisse der Aktivitäten.
    Alle Aktivitäten können auf den Referenzstack zugreifen und auf die gespeicherten Ergebnisse referenzieren, um diese als Parameter für ihre Funktionen zu verwenden.\\
    %Ein wichtiger Bestandteil der Prüfungslogik ist der Referenzstack. Der Referenzstack beeinhaltet alle Erge.
    %Die Aktivitäten können auf den Referenzstack zugreifen und abgespeicherte Ergebnisse referenzieren und diese als Parameter für ihre Aktionen verwenden.
    %Der Startpunkt jeder Prüfung ist die Startaktivität. Die Startaktivität darf pro Prüfung nur einmal vorkommen und ist dafür zuständig, dass der Referenzstack leer ist.
    %Die Reihenfolge der auszuführenden Aktivitäten wird durch die Aktivitäten vorgegeben. Die Aktiväten geben nämlich das Label der nächst zu folgenden Kante zurück. 
    %Die Prüfungs ist beendet, sobald die Aktivität kein Label mehr zurückgibt.\\
    \\
    \textbf{Datenverarbeitung}\\
    \\
    %einfügen,dass nach pull-ansatz gearbeitet wird
    %funktion zuständig für die berechnung der ausgabeports
    Die Ausführung der Datenverarbeitung basiert auf einer Execute-Funktion, die zur ausführung die Template-Parameter und eine Evaluate-Funktion benötigt.
    Für die vom System bereitgestellten Funktionen wird die Execute-Funktion direkt in Code implentiert. 
    Die Implementierung nutzt eine Hilfsklasse, die die Evaluate-Funktion bereitstellt und gleichzeitig die Werte der Ausgabeports speichert.
    Zudem muss die Implementierung sicherstellen, dass der Datenfluss zwischen Eingabe- und Ausgabeports korrekt hergestellt wird. Um dies zu gewährleisten, stellt die Klasse RuntimeContext gewisse Hilfsmethoden zur Verfügung.
    
    Eine wichtige Komponente der Datenverarbeitung ist der Ergebniscache. Im Ergebniscache werden die Werte der Ausgabeports gespeichert.
    Wird ein Wert für einen Eingabeport benötigt, so wird zunächst die Suche nach dem zugehörigem InputNode sowie der entsprechenden eingehen Kante. 
    Anschließend wird geprüft, ob für den Ausgabeport, der mit der Kante verbunden ist, ein Wert im Ergebniscache vorliegt.
    Ist dies nicht der Fall, wird die Funktion des Knotens ausgeführt und der Wert für den Ausgabeport im Ergebniscache gespeichert.\\
    Nicht nur für die normalen Funktion spielt der Ergebniscache eine große Rolle, sondern auch für die Lambda-Funktionen.
    Wenn ein Wert für einen Eingabeport einer Lambda-Funktion benötigt wird, wird zunächst der Wert der Ausgabeports, falls vorhanden, in dem Ergebniscache gespeichert.
    Im Anschluss daran wird für alle Funktionen, die im Kind-verhältnis zur Lambda-Funktion stehen, das Ergebnis im Ergebniscache invalidiert, indem das Ergenis aus dem Ergebniscache gelöscht wird.
    Anschließend wird der oben beschriebene Algortihmus verwendet, um die Werte für die Eingabeport der Lambda-Funktion zu berechnen.

    Als erstes werden alle Referenzen auf Flow-Templates aufgelöst, damit wir die Flow-Instanz erhalten. Sobald die Flow-Instanz erstellt ist, ist bekannt, welche Ports und Lambdas bei dem Funktions-Aufruf existieren und es werden Objektreferenzen zwischen den Ports erstellt.
    Die Objektreferenzen sollen die Modell Analyse erleichtern und beeinhalten Informationen über die Verbindung.
    Daraufhin werden die Refernz-Typen aufgelöst, indem diese durch konkrete Typen ersetzt werden.
    Nun kann mit der eigentlichen Validierung angefangen werden. Die Validierung wird pro Flow-Modell ausgeführt und es wird mit dem Flow-Modell angefangen, welches am wenigsten Abhänigkeiten auf andere Flow-Modelle hat.
    Bei der Prüfung wird über alle Verbindungen von Ports iteriert und falls ein gernerischer Typ vorkommt, wird diese Typ-Zuweisung gespeichert.
    Im Anschluss werden die Ports des Flow-Modells überprüft und versucht die generischen Typen aufzulösen. Gernerische Typen, welche nicht aufgelöst werden konnten, werden dann beim Flow-Aufruf aufgelöst. Vorausgesetzt die nicht zu auflösenden Typen sind Teil der Argumente und Ergbenisports des Flow-Models.
    Abschließend werden die Verbindungen von Flow-Ports validiert, indem diese auf Zuweisungskompatiblität überprüft werden, bei den übrig gebliebenen generischen Typen kommt es zu keinen Problemen, weil generische Typen in beide Richtungen zuweisungskopatibel sind.

    Als erstes muss eine Sortierung der Funktionen stattfinden, dabei werden zuerst die Abhängigkeiten der Funktion überprüft.
    Nachdem die Sortierung abgeschlossen ist, werden die Verbindungen auf Port-Fehler überprüft. Falls der Ausgabeport ein Fehler projeziert verursucht und der Verbundene Eingabeport keinen Fehler verarbeiten, dann gibt die Funktion des Eingabeports nicht ausgeführt und die Funktion gibt den Fehler als Ergebniss aus.

    Um zu überprüfen ob das Aktivitätsmodell valide ist, wird ein Typen-Referenzstack verwendet.
    Dabei wird das ganze Modell durchlaufen und für jede Aktivität der Stack berechnet.
    Bei der Berechnung wird die Schnittmenge über den Referenzstack der direkten Vorgänger Aktivitäten gebildet.
    Im Anschluss wird der Stack durch die auszuführende Aktivität erweitert.
    Zum Beispiel erweitert eine Aktionsaktivtät den Stack um einen Typen. 
    Hingegen Entscheidungsaktivität Einträge bearbeiten oder präzisieren können. Beispielweise werden bei einer erfolgreichen Validierungsentscheidung die betroffenden Typen im Stack konkretisiert. Dadurch sollen die Optionalen-Typ entfernt werden.
   
    Im Anschluss können dann die Nodes validiert werden. 
    Bei der Validierung wird geprüft ob das Argument $〈bool acceptsError〉$ der $〈FlowNodeInput〉$ den gleichen Wert wie der Refenzierte $〈FlowInputPort〉$ hat. Ist das nicht der Fall wird eine Fehlermeldung für das Flow-Modell ausgegeben.
    \subsection{Codeanalyse}
        Die aktuelle Umsetzung des Codes ermöglicht es aktuell nicht die geplante. Konkret lassen sich zwei Probleme aus der aktuellen Umsetzung ableiten:
        \begin{itemize}
            %\item Beim Validieren des Graphens wird überprüft, ob Zyklen vorliegen. Sollten Zyklen vorliegen werden error erzeugt.
            %\item Bei der umwandlung in einen ausführbaren Code werden alle Knoten des Graphens zu einer Funktion zusammengefasst. Bei Verzweigungen werden neue Funktionen erstellt. Bei einer Zusammenführung werden die einzelnen Funktionen gemergt.
            \item P1 Die Modellanalyse erlaubt keine Zyklen im Graphen
            \item P2 Die Ausführungsumgebung geht davon aus, dass Zyklen nicht erlaubt sind
        \end{itemize}\\
        \textbf{P1 - Die Modellanalyse erlaubt keine Zylken}\\
        \\
        Aktuell wird in der Klasse ActivityCycleCheckResolver überprüft, ob im Graphen Zyklen vorhanden sind. Die Überprüfung erfolgt dabei mithilfe des TODO Algorithmus.
        Der Algorithmus markiert als erstes in einem Dictonairy alle Knoten des Graphen als nicht besucht. 
        Anschließend wird eine tiefensuche über alle Knoten gemacht und jeder Knoten wird in eine Liste hinzugefügt. Dabei werden die Nachfolgenden Knoten als erstes der Liste hinzugefügt. Es erfolgt also ein topologisches Sortieren nach Post order.
        Auf der topolischen sortieren Liste wird eine erneute Tiefensuche durchgefügrt, die für jeden erreichbaren Knoten einen Komponent mit der gemeinsamen Wurzel (root) erstellt. Dabei werden Komponents als erstes für alle Vorgänger Knoten erstellt.
        Nun wurden alle zusammenhängende Elemente des Graphens gefunden und die zusammenhängende Elemente können in einem Dictonairy übertragen werden. Dabei wird der root der Schlüssel eines Dictonairy Elements sein und der Value der Knoten. 
        Hat ein Dictonairy Element mehr als ein Element im Value ist ein Zyklus vorhanden und diese Dictonairy Element wird in einem anderen Dictonairy gespeichert, welches zum erstellen von Fehlermeldungen verwendet wird\\
        \\
        Hier liegt auch das Problem. Wenn ein Zyklus erlaubt ist, darf das Dictonairy Element nicht im das Dictonairy für die Fehlermeldung gespeichert werden, sondern dieser Schritt muss übersprunen werden.\\
        \\
        \textbf{P2 - Die Ausführungsumgebung geht davon aus, dass Zyklen nicht erlaubt sind}\\
        \\
        In der Klasse VirtualMachineCompilerActivity wird das Modell in eine kompilierte Darstellung überführt. 
        Die Überführung funktioniert in der aktuellen Umsetzung so, dass eine Funktion erstellt wird und alle Knoten des Graphens nacheinander hinzugefügt wird.
        Bei einer Verzweigung wird eine extra Funktion erstellt, die ab der dem Punkt automatisch TODO. Bei einer Vereinigung werden die Funktionen wieder zu einer gemergt.
        Es wird aktuell nicht erkannt, ob der Knoten bereits hinzugefügt wurden ist.
        \\\\Hier liegt auch das Problem. Wenn Zyklen nun erlaubt sind, würde eine Endlosschleife entstehen, weil der Algorithmus den bereits hinzugefügten Teilgraphen erneut hinzufügen.
        Es muss also eine Möglichkeit geschaffen werden, dass mehrere TODO
    \newpage
    \section{TODO}
    \subsection{Anforderungsphase}
    Die geplante Erweiterung sieht die Einführung von zwei Schleifenblock vor, die die Wiederholung von Aktivitäten ermöglichen sollen. Dadurch soll es möglich sein Prüfungen mit dynamsichen Daten zu erstellen.
    Die Interaktion erfolgt über die bereits vorhandene grafische Benutzeroberfläche, in dieser kann der Benutzer die Anzahl der maximalen Iterationen und die Abbruchbedingung festlegen.
    Beide Blöcke sind von der Benutzeroberfläche gleiche und unterscheiden sich nur in der Logik.
    Dabei soll der Schleifenblock dem TODO ähneln. 
    Der Schleifenblock hat einen onFalse und einen onTrue Pfad, welcher Pfad genommen wird wird durch die Abburchbedingung bestimmt.
    Bei der Ausführung entscheidet der onFalse Zweig über eine mögliche Wiederholung. Die Entscheidung vom Block A basiert dabei auf die Anzahl der bereits ausgeführten Iteration. Hingegen Block B zusätzlich die Eingaben als Kriterium miteinbezieht.
    Der onTrue-Zweig führt zur beendigung des Schleifenblocks.
    \subsection{Entwursphase}
    Im vorherigen Unterkapitel wurde der Aufbau der Schleifenblöcke beschrieben. Nun wird die technische Umsetzung beschrieben. 
    Der Fokus wird dabei auf die Logik für die Entscheidung ob eine Wiederholung stattfindet oder nicht.
    Die beiden Schleifenblöcke, Block A und Block B, werden im folgenden einzeln betrachtet, da sie unterschiedliche Logiken haben. \\
    \\
    Durch die einführung des Schleifenblocks können Probleme entstehen, welches zu einem nicht gewollten Veralten führen können.
    Es ist möglich, dass Endlosschleifen entstehen können.\\
    \\
    \textbf{Block A}\\
    \\
    %TODO es muss unbedingt erwähnt werden dass die abbruchbedingung nun mehrmals teil des codes werden muss
    Block A soll die Wiederholung von Aktivitäten durch explizite Ausführung ermöglichen.
    Zur umsetzung dieses Ziels wird die Schleifenentfaltung als Grundlage verwendet.
    Unter Schleifenentfaltung versteht man, dass die Instruktione im Schleifenkörper mehrmals pro Iteration auszuausgeführt wird, um dadurch die häufigkeit der Iterationen zu verringern. \cite{9}
    Anstatt rekursive oder iterative Wiederholungen zu verwenden, wird jede potenzielle Iteration als eigenständigen und bedingten Codeblock realisiert.
    Dazu muss eine Anpassung an der klasisschen Schleifenentfaltungsverfahren vorgenommen werden. 
    Das Ziel der modifizierung ist es, die Schleifen solange zusammenzufassen bis kein erneuter Schleifendurchlauf notwendig ist und dadurch den Kontrollfluss durch Verzweigungen und verschtelungen ohne Iterationen abzubilden.
    Da die maximale Anzahl an Schleifendurchläufen von vorneherein bekannt ist, kann für jede potenzielle Ausführen des Schleifenkörpers eine Kopie erstellt werden. 
    In jeder Kopie wird der Schleifenkörper ausgeführt und anschließend um die Abbruchbedingung der Schleife ergänzt. Im Falle einer erfüllten Abbruchbedingung wird hingegen keine weitere Kopie ausgeführt. 
    Stattdessen wird die Ausführung gemäß dem vorgesehenen Kontrollfluss fortgesetzt.
    Auf Abbildung TODO wurde der Ansatz Graphisch dargestellt.
    In Abbildung TODO wird dieser Ansatz an einem konkreten Beispiel veranschaulicht.
    Im Beispiel soll "foo" drei mal einzeln auf der Console ausgegeben werden. 
    In der oberen Schleife
    Hingegen in der unteren Schleife der modifizierte Ansatz verwendet wurden ist. Da die untere Schleife nur noch genau einmal ausgefürt wird, kann diese einfach weggelassen werden.\\
    \\
    \textbf{Block B}\\
    \\
    Block B soll die Wiederholung von Aktivitäten durch iterative Schleifen ermöglichen.
    Ist die Abbruchbedingung nicht erfüllt, wird Entschieden ob eine Wiederholung stattfindet oder nicht. Dabei wird geschaut wie sich das dynamische Datum über die Iteration hinweg verhält.
    Es wird überprüft, ob die Anzahl der Iterationen bereits die maximale Anzahl an Iteration überschritten hat oder der Chancen-Zähler den Wert 0 erreicht hat.
    Da der Vergleich auf Mittelwerten basiert, müssen die Eingaben in einen Gleitkommawert umgewandelt werden.
    Zunächst wird dafür die Eingabe in eine Zeichenkette umgewandelt und anschließend versucht als Gleitkommazahlen zu interpretieren. 
    Schlägt die Interpretation fehl, handelt es sich nicht um eine Zahl. In dem Fall muss die Zeichenkette zeichenweise mithilfe von UTF-8 in eine Dezimalzhal überführt werden.     
    UTF-8 bietet sich zur Umwandlung an, da es bereits eine eindeutige und standardisierte Codierung für über 1,1 Millionen Unicode-Zeichen bereitstellt und somit keine zusätzliche Festlegung eines eigenen Codierungsschemas erforderlich ist.    
    Die einzelnen Zahlen werden dann mit ihren Index multipliziert und im anschluss addiert.
    Der Schritt mit der multiplizierung ist notwendig, weil die addtion kommutativ ist und somit keine berücksichtigung der Zeichenfolge erfolgt, wird durch Multiplikation mit der Zeichenposition eine positionsabhängige Gewichtung sichergestellt.
    Die Werte vom Typ double werden anschließend in einer Liste gespeichert, die alle bisherigen Eingaben beinhaltet.
    Basierend auf dieser Liste wird dann ein Mittelwert über alle bisherigen Werte gebildet und ein gleitender Mittelwert über die letzen 3 Werte.
    Anschließend wird die differenz zwischen den aktuellen Wert und den Mittelwerten gebildet. ist die differenz kleiner als ein threshold wird der counter dekremntiert. ist die differenz gleich oder größer als der Threshold wird der Chancen-Zähler zurückgesetzt.
    Erreicht der Chancen-Zähler 0 werden keine weiteren Wiederholungen ausgeführt, da der wert sehr wahrscheinlich stagniert.
    Der Chancen-Zähler erweist sich als erforderlich, da dieser als Steuermechanismus für die Wiederholungslogik dient und eine Begrenzung der Iterationen bei ausbleibender signifikanter Veränderung sicherstellt.
    Dadurch soll verhindert werden, dass eine ineffiziente Fortsetzung der Schleife stattfindet.
    Sollten weniger als 3 Werte in der Ergbenissliste drin sein, wird die Berechnung übersprungen. Dadurch kann gewährleistret werden, dass das System einlaufen kann und die Mittelwerte erst gebildet werden, wenn eine aussagekräftige Datenbasis vorhanden ist.\\
    \\
    Auf die Vor- und Nachteile der einzelnen Blöcke wird im späteren Verlauf eingegangen.

    \newpage
    \section{Implementierung}
    In diesem Kapitel wird die vorgenommene Implementierung beschrieben. Dabei wird zunächst TODO in Teilbereiche unterteilt und anschließend die funktionsweise der einzelnen Änderungen erklärt.
    Als Grundlage für dieses Kapitel werden die vorangegangen Kapitel dienen insbesondere Kapitel TODO.
    Das Ziel ist es die Implementierung verständlich und nachvollziehbar zu machen.\\
    \\
    %TODO parameter erwähnen ja oder oder nein?
    %Die Funktionalität der Klasse wird durch die drei Methoden calcute, calculateMean und isDeviationWithinThreshold realisiert.
    Zur umsetzung der Wiederholungslogik im Block B wurden vier Klassen definiert.
    Dabei handelt es sich unter anderem um die Klasse DeviationChecker, die in Abbildung TODO dargestellt ist.\\
    Ziel der Klasse ist es den Mittelwert zu berechnen und die Differenz zum aktuellen Wert auf ihren Schwellenwertüberschreitung hin zu überprüft.
    Zur Umsetzung dieser FUnktionalität hat DeviationChecker eine Mittelwert-Variable vom Datentyp Double sowie die drei Methoden calcute, calculateMean und isDeviationWithinThreshold.\\
    \\
    Die Methode calculateMean übernimmt die Berechnung des aktuellen Mittelwerts, indem über die Liste der Eingaben iteriert wird und diese aufsummiert werden.
    Der berechnete Summenwert wird durch TODO geteilt und anschließend als Rückgabewert zurückgegeben.\\
    Mit Hilfe der Methode isDeviationWithinThreshold wird die Differenz berechnet und überprüft ob die Differenz den Schwellenwert unterschreitet.
    Dies erfolgt durch die Berechnung des Betrags der Differenz zwischen Mittelwert und dem aktuellen Wert.
    Je nach Ergebnis wird dann ein entsprechender Wahrheitswert zurückgegeben.\\
    Der Ablauf der Klasse wird in der Methode calculate gesteuert. Hier wird zunächst überprüft, ob die anderen Methoden aufgerufen werden soll.
    Der Algorithmus wird lediglich bei Vorhandensein von mindestens drei Werten in der Eingabeliste gestartet.
    Ist dies der Fall wird die Methode calculateMean aufgerufen und dessen Rückgabewert in die Mittelwert-Variable gespeichert.
    Im Anschluss erfolgt der Aufruf von isDeviationWithinThreshold, dessen Rückgabewert von calculate zurückgegeben wird.\\
    \\
    \\
    Ein andere Klasse ist Counter.
    Diese dient der Verwaltung zweier Zählerwerte: chance und counter.
    Der Zugriff auf diese Variablen erfolgt nach dem Prinzip der Datenkapslung.
    Zur Funktionalität stehen Methoden zum Verrigern (decreaseChance und decreaseCounter), Zurücksetzen (resetChance) sowie Setzen und Auslesen (setCounter, getCounter, getChance) der Zählerwerte zur Verfügung.\\
    \\
    \\
    Mit der Klasse StringToDoubleConverter wird ein String in einen Double-Wert umgewandelt.
    Um dies zu ermöglichen stellt die Klasse verschiedene Variable zur verfügung, darunter eine Variable für den Zähler der Schleife, einen für die Bytes und einen für den umgewandelten Wert.
    Die Methode StringToDouble konviert die Zeichenkette, indem sie zunächst die Zeichenkette in UTF-8 kodierte Bytes umgewandelt.
    Anschließend werden die Bytes mit einem fortlaufenden Index multipliziert und auf einen Akkumulator addiert.
    Der akkumulierte Wert wird im Anschluss als Rückgabewert zurückgegeben.\\
    \\
    \\
    Die letzte der vier Klassen ist InputProcessor.
    Diese ist für die Verarbeitung der Eingabewerte zuständig.
    Zur Verarbeitung stehen mehrere interne Datenstrukturen und konstanten zur verfügung, darunter zwei Listen zur Speicherung der Roh- und Konvertierungswerte sowie Parameter zur Konfiguration (HistoryLength und deviationThreshold) und eine Instanz der Klasse Counter.
    Die Methode processInput übernimmt TODO und überprüft zunächst ob eine weitere Verarbeitung zulässig ist. 
    Als Kriterium dafür wird der aktuelle Stand der Klasse Counter herangezogen.
    Ist eine weiter verarbeitung zulässig wird zuerst TODO und der Eingabewert mithilfe der Methode storeInput in eine Liste gespeichert.
    Anschließend wird der Eigabewert mit der Methode convertInputToDouble in einen Double-Wert konvertiert.
    Dieser Wert wird nach der Konvertierung dann in eine Liste gespeichert.
    Im Anschluss daran wird mithilfe der Methode validateDeviation der konvertierte Wert auf eine mögliche Abweichung hin überprüft.
    Als letzter Schritt der Verarbeitung wird der Zähler dekrementiert.\\
    \\
    Die Methode convertInputToDouble TODO. Ist dies nicht möglich, wird der Eingabewert mit der Methode StringToDouble aus der Klasse StringToDoubleConverter in einen Double-Wert konviert.
    Als Rückgabewert wird der Double zurückgeben.\\
    \\
    Mithilfe der Methode validateDeviation wird überprüft, ob der Eingabewert eine signifikate Abweichung im Vergleich zur Historie aufweist.
    Dafür wird zunächst der Index des letzten Elements aus der Liste bestimmt und anschließend die Abweichungsberechnung über die Methode calcute der Klasse DeviationChecker durchgeführt.
    Liegt eine signifikante Abweichung vor wird der Zähler resetet. Ist hingegen keine Abweichung vorhanden wird der Zähler dekremntiert.\\
    \\
    Damit Zyklen übern den Schleifenblock erlaubt sind und es zu keinen Fehler kommt, muss die Zylkenüberprüfung angepasst werden.
    Wie die Zylkenüberprüfung funktioniert wurde bereits in Kapitel TODO beschrieben.
    Die Änderung am diesem Algorithmus muss an der Stelle stattfinden an der die TODO.
    Hier muss bevor TODO geschaut werden ob der Root der Schleifenblock ist.
    Ist dies der Fall Fall wird der Funktionsaufruf übersprungen.
    Dadurch wird für die Rückverbindung kein ComponentEntry erstellt bei dem root und element ungleich snd. 
    So eine Kombinantion führt nämlich im weiteren Verlauf dazu, dass ein Eintrag im Fehler Dicentario erstellt wird und dadurch Rückführung ungültig ist.    
    Da der Algorithmus die einzelnen Knoten über IDs identifiziert, muss eine Liste erstellt werden, welche alle IDs der Schleifenblöcke beeinhaltet. 
    Bei der überprüfung wird nun geschaut ob die ID des roots in der Liste ist. 
    Ist der Root in der Liste handelt es sich um einen Schleifenblock. 
    Um eine Liste mit den IDs zu erstellen, kann eine Kombination aus den Methoden where und select und kommen aus der statischen Klasse Enumerable im Namensraum System.Linq. 
    Durch where wird TODO gefildert und mit select wird die gefilderte TODO projektiert.
    %\subsection{1. Lösungsansatz}
    %Schleife soll durch ein Schleifenkonstruktor dargestellt werden.
    %Prüfungslogik muss eine weitere Aktivitätsaktion erweitert werden. Das Schleifenkonstrukt greift dabei auf bereits vorhandene Regeln der Prüfungslogik zu.
    %Das Schleifenkonstrukt greift dabei wie die anderen Aktivitätsaktionen auf den Referenzstack zu. Da der nächste Schleifendurchlauf nicht wieder auf den gleichen Eingabenwerten laufen soll, da diese wieder zu einem fehlerhaften Wert führen wird, muss ein Mechanismus im Schleifenkonstrukt implementiert werden, welcher einen neuen Wert holt.
    %Der Schleifenkörper wird dabei nicht mithilfe von Rekursion oder Iteration ausgeführt, sondern durch entfaltung. 
    %Ye et al. beschreiben Schleifenentfaltung als eine gängige Methode um Compiler zu optimieren, weil mit dieser Methode die mehreren Schleifendurchläufe zu einer zusammengefasst werden. \cite{9}
    %Huang et al. beschreiben den ALgortithmus wie folgt TODO.
    %Der beschrieben Ansatz kann für unseren Ansatz nicht 1:1 übernohmen werden, sondern muss etwas modifiziert werden. Unser Ziel ist es nicht nur einzelene Schleifendurchläufe zusammen zu fassen, sondern die ganzen Schleifendurchläufe in einer einzigen zusammenzufassen.
    %Da bei unseren Lösungsansatz die maximale Anzahl an Schleifendurchläufen begrenzt ist und diese bereits vor der Ausführung der Prüfungs bekannt ist, kann diese Information beim modifizierten Ansatz berücksichtigt werden. Ein Beispiel in in Abbildung TODO.
    %Bei dem Beispiel ist die Anzahl der Schleifen Durchläufe auf 3 begrenzt. In beiden Schleifen soll die Zeichenkette "Foo" 3-mal auf der Konsole ausgegeben werden. 
    %Der Schleifenkopf initalisiert am Anfang eine Variable. Anschließend wird eine Abbruchbedigung definiert und im Anschluss die veränderung der Variable pro Schleifendurchlauf festgelegt.
    %Im Beispiel 1 wird die Funtkion console.log("Foo") pro Schleifendurchlauf einmal ausgeführt.
    %Hingegen im Beispiel 2 wurde die Schleife entfaltet und die Funktion console.log("Foo") pro Schleifendurchlauf 3-mal ausgeführt. Da die Schleife aber nur noch einmal ausführt und dann abbricht, kann diese auch weggelassen werden.
    %Zwischen den einzelnen Funktionen muss dafür gesorgt werden, dass die neue Wert zur verfgügung steht. Deswegen ist die Idee alle bisherigen Aktivitätaktion zu wiederholen, damit der aktuellste Wert vom Hauptuntersuchungs-Adapter ausgelesen wird und die Prüfung aufgrundlage dieses Wertes nochmals ausgefürt wird. Ein Beispiel ist in Abbildung TODO.
    %\VerbatimInput[numbers=left]{schleifen.js}
    %\textbf{Abbildung TODO}\\
    %Der Benutzer gibt von vorneherein eine Zahl a an, welche die maximale Anzahl von Schleifendurchläufe beschränkt. Für die Zahl muss dafür folgendes gelten TODO.
    %Die Idee des Ansatzes ist es, den Schleifenköper nicht Iterativ oder Rekursiv ausführen, sondern a-mal auszurollen.
    %Dafür wird der Schleifenköper und die nachfolgenden Anweisungen a-mal kopiert. Die Schleife wird dadurch nicht dynmasisch ausgeführt, sondern statisch in den Code implementiert. Dadurch entstehen $a+1$ Graphen. Jeder dieser Graphen repräsentiert einen ursprüngliche Iteration. Dabei werden die einzelnen Graphen mit ihren direkten Nachbaran verbunden. 
    %Da die aktuell zugrunde liegende Implementierung determenistisch ist und aktuell nur auf die gleiche Eingabe zugegriffen werden kann, muss ein Mechanismus implementiert werden, welcher den aktuellen Sensorwert ausliest und diesen an die nachfolgenden Anweisungen weitergibt. Dieser Vorgang muss für jede neu eingefügte Verbindung wiederolt werden.
    %\resizebox*{!}{10cm}{
    %\begin{tikzpicture}[]
        %\node[state, initial text=""](q5){};
        %\node[state, rectangle, below = 1cm of q5](q6){Aktion1};
        %\node[state, rectangle, below = 1cm of q6](q7){Aktion2};
        %\node[state, below = 1cm of q7](q8){Entscheidung};
        %\node[state, rectangle, accepting, below = 1cm of q8](q9){Ausgabe};

        %\node[state, rectangle, right = 2cm of q6](q10){Aktion1};
        %\node[state, rectangle, right = 2cm of q7](q11){Aktion2};
        %\node[state, below = 1cm of q11](q12){Entscheidung};
        %\node[state, rectangle, accepting, below = 1cm of q12](q13){Ausgabe};

        %\node[state, rectangle, right = 2cm of q10](q14){Aktion1};
        %\node[state, rectangle, right = 2cm of q11](q15){Aktion2};
        %\node[state, below = 1cm of q15](q16){Entscheidung};
        %\node[state, rectangle, accepting, below = 1cm of q16](q17){Ausgabe};

        %\draw(q5) edge[->] (q6);
        %\draw(q6) edge[->] (q7);
        %\draw(q7) edge[->] (q8);
        %\draw(q8) edge[->] (q9);
        %\draw(q8) edge[->] (q10);
        
        %\draw(q10) edge[->] (q11);
        %\draw(q11) edge[->] (q12);
        %\draw(q12) edge[->] (q13);
        %\draw(q12) edge[->] (q14);

        %\draw(q14) edge[->] (q15);
        %\draw(q15) edge[->] (q16);
        %\draw(q16) edge[->] (q17);


    %\end{tikzpicture}
    %}\\
    %\textbf{Abbildung TODO}\\
    %\subsection{2. Lösungsansatz}
    %Schleife soll durch ein Konstrukt realisiert werden.
    %Prüfungslogik muss um eine weitere Aktivitätsaktion erweitert werden. Das Schleifenkonstrukt greift dabei auf bereits vorhandene Regeln der Prüfungslogik zu.
    %Das Schleifenkonstrukt greift dabei wie die anderen Aktivitätsaktionen auf den Referenzstack zu. Da der nächste Schleifendurchlauf nicht wieder auf den gleichen Eingabenwerten laufen soll, da diese wieder zu einem fehlerhaften Wert führen wird, muss ein Mechanismus im Schleifenkonstrukt implementiert werden, welcher einen neuen Wert holt.
    %Durch die einführung der Schleife entstehen neue Herausforderungen. Es können nun Endlosschleifen entstehen, welche dazuführen dass die ausgeführte Prüfung niemals terminieren wird. Außerdem liefert der Hauptuntersuchungs-Adapter keine linearen Werte (?), sondern nicht determenistische Werte.

    %Eine Endlosschleife kann von vorneherein ausgeschlossen werden, indem die maximalen Schleifendurchläufe begrenzt werden. 
    %Da die Werte des Hauptuntersuchungs-Adapter nicht vorhersehbar sind und die Prüfung nicht jedes mal die maximale Anzahl der Schleifendurchläufe ausführen soll, muss ein Algorithmus entwickelt werden, welcher sagt wann man davon ausgehen kann, wann die ausgelesenen Sensorwerte sicht großartig nicht mehr ändern und stabil sind.
    
    %Ein möglicher Lösungsvorschlag könnte nun folgendermaßen aussehen. 
    %Je nachdem welcher Typ der Eingabewert hat verläuft der Algorithmus anders. Es wird dabei nur zwischen Zahlen und Zeichenketten unterschieden. 
    %Bei Zeichenketten wird der aktuelle Wert mit dem Wert aus dem vorherigen Schleifendurchlauf verglichen. Dafür wird die Levenshtein-Distanz verwendet. Für die ersten beiden Schelifendurchläufe wird der Algorithmus übersprungen, weil die Levenshtein-Distanz noch kein Aussagekräftiges Ergebnis für den Anwendungsfall geben kann.
    %Die Levenshtein-Distanz gibt die ähnlichkeit zwischen zwei Zeichenketten als Zahl an, indem sie die minimale Anzahl an Operation angibt, welche benötigt werden, damit die erste Zeichenkette der zweiten Zeichenkette gleicht. Je größer die Zahl ist destso "unterschiedlicher" sind die beiden Zeichenketten von einander. 

    %Um zu schauen wie sich die Eingabe zu verschiedenen Zeiträumen verhält, berechnen wir Mittelwerte über TODO. Es sollten mindestens zwei Mittelwerte gebildet werden. Mehr als zwei Mittelwerte sind möglich, aber würden den Algorithmus entwindlicher machen. Der erste Mittelwert sollte über alle bisherigen Eingaben gebildet werden, um zu sehen wie sich die Eingabe auf langer Sicht verhält. Der zweite Mittelwert sollte über die letzten n Eingaben gebildert, um zu sehen wie sich die Eingabe auf kurzer Sicht verhält.
    %Da die Werte der Levenshtein-Distanz sich für den Mittelwert nicht besonders anbieten, müssen die Zeichenketten in einen Zahlenwert umgewandelt werden.hließend Addieren. Für die Umwandlung eignet sich UTF-8 besonders gut. Da UTF-8 fast akke Schriftzeichen weltweit beinhaltet.
    %Das kann geschaffen werden indem alle Zeichen der Zeichenkette in eine eindeutige Zahl umwandeln und die einzelnen Zahlen ansc
    %Zusätzlich muss eine Gewichtung bei der Addition berücksichtigt werden, weil sonst Zeichenketten, die aus den gleichen Zeichen bestehen, den gleichen Wert bei der Addition rausbekommen. Das liegt daran, dass bei der Addition ohne Gewichtung nur die Wertigkeit der einzelnen Zeichen betrachtet wird, aber nicht deren Position. Dieses Problem wird mit der Gewichtung aufgelöst. Ein Beispiel dafür für die Addition mit Gewichtung ist in Abbildung TODO.
    %Dies muss aber nicht für jedes Eingabepaar gemacht werden, sondern nur für Eingabepaare welche sich sehr ähneln, also eine niedrige Levenshtein-Distanz haben. Für Eingabepaare mit einer hohen Levenshtein-Distanz ist das nicht notwendig, weil wir da bereits wissen, dass sich die Zeichketten stark von einerander unterscheiden.
    %Ist die Differenz aus der umgewandelten umgewandelten Zeichenkette und einem Mittel kleiner als ein vordefinierter Schwellenwert, wissen wir dass die Zeichenkette sich nur ganz leicht von den durchschnittlichen Eingaben unterscheidet.
    %Wenn dies nun mehrmals nacheinander vorkommt, kann davon ausgegangen werden, dass der Wert in diesen Wertebereich stagniert.
    %Um dies im ALgortithmus auch zu berücksichtigen, wird ein n-Chance Mechanismus eingebaut der folgendermaßen Funktioniert:
    %\begin{itemize}
        %\item Wird der Schwellenwert unterschritten, wird unser n dekrementiert.
        %\item Wird der Schwellwert übertroffen oder ist unsere Differenz gleich wird n zurückgesetzt.
        %\item Erreicht n irgendwann die 0 wird die Schleife abgebrochen. 
    %\end{itemize}
    %Beispiel
    %$
        %"foo" = 102 + 111 + 111 = 324
        %"oof" = 111 + 111 + 102 = 324
        %mit Gewichtung
        %"foo" = 1 * 102 + 2 * 111 + 3 * 111 = 657
        %"oof" = 1 * 111 + 2 * 111 + 3 * 102 = 639
    %$
    %\\\textbf{Abbildung TODO} Beispiel Addition mit und ohne Gewichtung
    %\\\\Ist unser Eingabewert nun keine Zeichenkette, sondern eine Zahl entfällt der Umwandlungsschritt mit der Gewichtung. Es kann sofort mit den beschriebenen Mittelwertansatz angefangen werden.
    %Schleifenkonstrukt -> Benutzer gibt Abbruchbedigung ein (Benutzer verwendet Schleifenkonstrukt statt Entscheidungs Aktivität) -> 
    %typ (generisch?, damit das System dies für uns übernimmt) der eingabe muss bestimmt werden, damit richtiger algorithmus zur stabilität überprüfung ausgewählt werden kann (es wird nur zwischen zeichenketten und zahlen unterschieden => bei zahlen wird mittelwertansatz gewählt bei zeichenketten Levenshtein-Distanz)
    %Was muss geändert werden: Prüfungslogik muss durch die aktivität schleife erweitert werden
    %Schluss
    \newpage
    \section{Evaluation}
    \label{Evaluation}
    Das Programm wurde auf einem System mit einem AMD Ryzen 5 2600 mit 6 Kernen und einer Taktrate 3400MHz ausgeführt. Als Arbeitsspeicher waren 2-Mal 8GB eine TODO eingebaut. 
    Als Betriebssystem war Windows 10 in der Version 10.0.19045 BUild 19045 installiert. Als Laufzeitumgebung wurde dotnet 8 einesetzt.\\
    \\
    Zur messen der Ausführungszeit wurde die Klasse Stopwatch verwendet, die eine Menge an Methoden und Eigenschaften bereitstellt um verstrichene Zeit zu messen.
    Hingegen zum messen des Speicherverbrauchs die Klasse GC verwendet wird, die eine Menge von Methoden und Eigenschaften bereitstellt um Speicher zu verwalten.
    GC hat nicht die Möglichkeit sofort den Speicherverbrauch zu messen, aber mithilfe der Methode get
    %\subsection{1. Lösungsansatz}
    %+einfach zu implementieren, da wir kein schleifenkonstrukt mehr benötigen.
    %+keine Endlosschleife, weil es keine Schleifen gibt
    %+keine Zyklen, weil der Ablauf linear ist
    %+weniger Sprünge, weil keine for oder while Bedingungen vorhanden sind
    %+möglicher Performance gewinn, weil Schleifen-Overhead entfällt
    %-größerer Codeumfang, da der eigentliche schleifenkörper a-mal im code implemtniert werden muss 
    %-höherer verbraucht an ressourcen zB Speicher mehr code = mehr speicher
    %-möglicherweise ineffizient, wenn der faktor zu groß gewählt wird
    %-schlechtere Lesbarkeit
    %-wenn bereits nach 3 durchlaufen feststeht, dass das gewünschte ergbeniss nicht mehr erreicht werden kann werden trotzdem die restlichen schritte ausgeführt
    %\subsection{2. Lösungsansatz}
    %+keine Endlosschleife, weil maximale Schleifendurchläufe begrenzt sind.
    %+
    %-azyklisches verhalten wird verletzt, weil schleifenkonstrukt benötigt wird
    %-
    \newpage
    \renewcommand{\refname}{}
    \section{Literaturverzeichnis}
    \begin{thebibliography}{9}
        \bibitem{2}Johnston, W., Hanna, J., \& Millar, R. (2004). \emph{Advances in dataflow programming languages}. ACM Computing Surveys, 36(1), 1–34.
        \bibitem{3}Chen, L. (2021). \emph{Iteration vs. Recursion: Two Basic Algorithm Design Methodologies}. SIGACT News, 52(1), 81–86.
        \bibitem{4}Arvind, \& Culler, D. (1986). \emph{Dataflow Architectures}. LCS Technical Memos.
        \bibitem{5}Ambler, A., \& Burnett, M. (1990). \emph{Visual forms of iteration that preserve single assignment}. Journal of Visual Languages \& Computing, 1(2), 159–181.
        \bibitem{6}Mosconi, M., \& Porta, M. (2000). \emph{Iteration constructs in data-flow visual programming languages}. Computer Languages, 26(2), 67–104.
        \bibitem{1}Fan, Z., Li, W., Liu, T., Tang, S., Wang, Z., An, X., Ye, X., \& Fan, D. (2022). \emph{A Loop Optimization Method for Dataflow Architecture}. In 2022 IEEE 24th Int Conf on High Performance Computing \& Communications; 8th Int Conf on Data Science \& Systems; 20th Int Conf on Smart City; 8th Int Conf on Dependability in Sensor, Cloud \& Big Data Systems \& Application (HPCC/DSS/SmartCity/DependSys) (pp. 202–211).
        \bibitem{7}Gévay, G., Soto, J., \& Markl, V. (2021). \emph{Handling Iterations in Distributed Dataflow Systems}. ACM Comput. Surv., 54(9), 199:1–199:38.
        \bibitem{8}Alves, T., Marzulo, L., Kundu, S., \& França, F. (2021). \emph{Concurrency Analysis in Dynamic Dataflow Graphs}. IEEE Transactions on Emerging Topics in Computing, 9(1), 44–54.
        \bibitem{9}Ye, Z., \& Jiao, J. (2024). \emph{Loop Unrolling Based on SLP and Register Pressure Awareness}. In 2024 20th International Conference on Natural Computation, Fuzzy Systems and Knowledge Discovery (ICNC-FSKD) (pp. 1–6).
        \bibitem{10}Lučanin, D., \& Fabek, I. (2011). \emph{A visual programming language for drawing and executing flowcharts}. In 2011 Proceedings of the 34th International Convention MIPRO (pp. 1679–1684).
        \bibitem{11}Davis, A., \& Keller, R. (1982). \emph{Data Flow Program Graphs}. All HMC Faculty Publications and Research.
        \bibitem{21}Boshernitsan, M., \& Downes, M. (2004). \emph{Visual Programming Languages: A Survey}. EECS University of California, Berkeley.
        \bibitem{12}Charntaweekhun, K., \& Wangsiripitak, S. (2006). \emph{Visual Programming using Flowchart}. In 2006 International Symposium on Communications and Information Technologies (pp. 1062–1065).
        \bibitem{13}Burnett, M., Baker, M., Bohus, C., Carlson, P., Yang, S., \& Van Zee, P. (1995). \emph{Scaling up visual programming languages}. Computer, 28(3), 45–54.
        \bibitem{14}Kurihara, A., Sasaki, A., Wakita, K., \& Hosobe, H. (2015). \emph{A Programming Environment for Visual Block-Based Domain-Specific Languages}. Procedia Computer Science, 62, 287–296.
        \bibitem{15}Hils, D. (1992). \emph{Visual languages and computing survey: Data flow visual programming languages}. Journal of Visual Languages \& Computing, 3(1), 69–101.
        \bibitem{19}Sousa, T. (2012). \emph{Dataﬂow Programming Concept, Languages and Applications}. Doctoral Symposium on Informatics Engineering, 7.
        \bibitem{18}Van Deursen, A., Klint, P., \& Visser, J. (2000). \emph{Domain-specific languages: an annotated bibliography}. ACM SIGPLAN Notices, 35(6), 26–36.
        \bibitem{16}Roy, G., Kelso, J., \& Standing, C. (1998). \emph{Towards a visual programming environment for software development}. In Proceedings. 1998 International Conference Software Engineering: Education and Practice (Cat. No.98EX220) (pp. 381–388). IEEE Comput. Soc.
        \bibitem{20}Weintrop, D. (2019). \emph{Block-based programming in computer science education}. Communications of the ACM, 62(8), 22–25.
        \bibitem{22}Gumm, H.P., \& Sommer, M. (2016). \emph{Band 1 Programmierung, Algorithmen und Datenstrukturen}. De Gruyter Oldenbourg.
    \end{thebibliography}
\end{document}    