\documentclass{article}
\usepackage{syntax}
\usepackage{struktex}
\usepackage{fancyvrb}
\usepackage[ngerman]{babel}
\usepackage[protrusion=true, expansion=true]{microtype}
\usepackage{float}
\usepackage[labelfont=bf,justification=raggedright,singlelinecheck=false]{caption}
\usepackage{pgfplots}

\begin{document}
    \tableofcontents
    \newpage
    \includegraphics[width=\linewidth]{./image/a.pdf}
    \section{Einleitung}
    %TODO erwähnen wie viele quellen gesichtet wurden sind
    \subsection{Aufgabe und Motivation}
    Prüfungen, die mithilfe grafischer Editoren modelliert werden, müssen in vielen Fällen eine Vielzahl von wiederkehrenden Aufgaben abbilden. 
    Diese Wiederholungen können bei der aktuellen Implementierung nur schwer abgebildet werden, weil Schleifen als Konstrukte nicht zur Verfügung stehen. 
    Stattdessen müssen zu wiederholende Abläufe mehrfach und explizit modelliert werden. 
    Dies führt zu Redundanz, erhöht die Komplexität der Modelle und erschwert deren Wartbarkeit.\\
    \\
    In klassischen Programmiersprachen wird das Problem der Wiederholung durch die Verwendung von Schleifenkonstrukten gelöst, welche eine kompakte und dynamische Modellierung ermöglichen. 
    In grafischen Editoren ohne native Unterstützung von Schleifen ist es hingegen notwendig, Prüfungen statisch und mehrfach abzubilden. 
    Eine pragmatische Lösung besteht darin, Prüfungen mehrfach auszuführen oder die zu wiederholenden Abläufe manuell zu duplizieren und diese mit bedingten Verzweigungen zu Verbinden. 
    Dies ist jedoch oft nicht praktikabel, weil Prüfungen häufig an variable oder unvorhersehbare Bedingungen angepasst werden müssen.
    Die einzige Möglichkeit, um dynamische Daten während einer Prüfung effizient und wartbar zu bearbeiten, besteht darin, ein Schleifenkonstrukt in das bestehende System zu integrieren. 
    Daraus ergibt sich ein klares Interesse, entsprechende Erweiterungen zu konzipieren und zu implementieren.\\
    \\
    In dieser Arbeit sollen mehrere Möglichkeiten konzepiert und implementiert werden, welche es ermöglichen sollen dynamsiche Daten innerhalb einer Prüfung zu verarbeiten.
    Bei dynmaischen Daten handelt es sich um Daten, die während der Prüfung ihren Wert ändern.
    Dafür muss im Vorfeld das zugrunde liegende System analysiert und bearbeitet werden, sodass Zyklen vom System verarbeitet werden können.
    Die Implementierung wird in einer Evaluation auf TODO untersucht.
    \subsection{Aufbau der Arbeit}
    Die vorliegenede Arbeit setzt sich aus TODO nachfolgenden Kapiteln zusammen. 
    Im zweiten Kapitel TODO
    Anschließend daran wird im dritten Kapitel TODO
    Darauf aufbauen wird im vierten und fünften Kapitel TODO
    Der Fokus im letzten Kapitel liegt auf TODO 
    \newpage
    \section{Hintergrund}
    Der Fokus dieses Kapitels liegt auf der Definition zentraler Fachbegriffe und TODO um dadurch einen einheitlichen terminologischen Rahmen zu schaffen. 
    Das Ziel dieses Kapitels ist es die Verständlichkeit der nachfolgenden Kapitel zu erhöhen und die theoretischen Grundlagen der Arbeit zu festigen.
    \subsection{Terminologie}
    \label{Terminologie}
    \textbf{Schleifen}\\
    \\
    Eine Schleife ist eine Kontrollstruktur, die einen Programm-Abschnitt mehrmals ausführt \cite{22}.
    Häufig ist diese dabei die zeitintensivste Komponente eines Programms, da ihre die Ausführung sehr viel Zeit in anspruch nehmen kann \cite{1}.
    Der Algrorithmus dieser Kontrollstruktur kann dabei iterativ oder rekursiv implementiert werden. Ersteres wiederholt die Schleife mehrmals. Hingegen die Rekursion sich mehrmals selbst aufruft \cite{3}.
    Zur umsetzung verwendet die Iteration einen Akkumulativenansatz. Dabei wird das Problem schrittweise gelöst. Der Prozess wird solange wiederholt bis eine vordefinierte (Abbruch-)Bedingung erfüllt ist \cite{3}.
    Im gegensatz zur Iteration verwendet die Rekursion keinen Akkumulativenansatz, sondern zerlegt das Problam in mehrere (Teil-)Probleme. Für die Teilprobleme werden dann einzelne Lösungen erarbeitet, welche im Anschluss wieder kombiniert werden um das eigentliche Problem zu lösen \cite{3}.
    Laut Chen L. spiegelt die Iteration das menschliche Denken wieder, weshalb sie sich besonders für lineare Probleme eignet. 
    Die Rekursion hingegen ist für Probleme geeignet, welche Zwischenergebnisse oder Teillösungen benötigen \cite{3}.
    Eine Schleife kann dabei in zeitabhängig oder horizontal unterteilt werden. Bei einer zeitabhängigen Schleife hängt das Ergebnis des aktuellen Schleifendurchlaufs vom Ergebnis des vorherigen Schleifendurchlaufs ab. Hingegen sind die Ergebnisse der Schleifendurchläufe bei der horizontalen Schleife unabhängig voneinander \cite{5}.\\
    \\
    \textbf{Domain Specific Language}\\
    \\
    Bei einer domänenspezifische Sprache (DSL) handelt es sich um eine Programmiersprache, die mit dem Ziel entwickelt wurden ist, spezifische Aufgabenstellungen innerhalb eines begrenzten Anwendungskontexts (Domaine) besonders effektiv zu lösen \cite{18}.
    DSLs bilden das Gegenstück zu General-Purpose Languages (GPL) wie Java, C++ oder Python \cite{14}.
    Anders als bei GPLs verfügen DSLs oftmals über eine reduzierte Syntax, die ausschließlich für die jeweilige Domaine relevant ist. Teilweise wird DSLs durch GPL ergänzt \cite{18}.
    Bei DSLs wird zwischen externen und internen DSLs unterschieden. Externe DSLs haben ihre eigene Syntax. 
    Dadurch kann eine größere flexibilität geschaffen werden, aber zeitglich ist der Aufwand für den Entwickler sehr hoch, weil alle relevanten Tools selbst implementieren werden müssen. 
    Außerdem braucht der Benutzer länger Zeit um die Syntax zu lernen \cite{7}.
    Zur Laufzeit wird dann die externe DSLs in eine GPL übersetzt.
    Bei internen DSLs hingegen wird die Syntax einer GPL verwendet. 
    Die interne DSL kann dann oft über eine Programmierschnittstelle oder Bibliothek aufgerufen werden \cite{14}.
    Ein Beispiel für eine externe DSL ist SQL.
    Ein Beispiel für eine interne DSL ist Rake.
    Die Vorteile von DLSs liegen in ihrer strukturellen Klarheit und Spezialisierung. Dem gegenüber stehen die Nachteile eines hohen Initialaufwands sowie einer begrenzten Flexibilität und Verfügbarkeit \cite{18}.\\ 
    \\
    \textbf{Visual Programming Language}\\
    \\
    Visuelle Sprachen (VL) sind Sprachen, bei denen die Informationsdarstellung primär über grafische Elemente und nicht über textuelle Komponenten erfolgt \cite{5}.
    Dabei werden hauptsächlich grafische Tools und visuelle Metaphan verwendet. 
    Bilder eignen sich besonders gut zum Programmieren, weil diese ausdruckstärker als Worte sind und einen höheren Wiedererkennungswert haben.
    Nachteile gegenüber Text-basierten Sprachen sind, dass VLs durch die eigeschränkte Syntax nicht so ausdruckstark und flexibel sind \cite{16}.\\
    \\
    Eine spezielle Form visueller Sprachen stellen die visuellen Programmiersprachen (VPL) dar, bei denen grafische Darstellungen gezielt für die Erstellung von Programmen genutzt werden.    
    Das Hauptziel von VPLs besteht in der Verbesserung der Darstellung der Programmierlogik sowie in der Erleichterung des Verständnisses von Programmabläufen \cite{13}.
    Dadurch soll der Fokus bei Programmieren stärker auf die konzeptuellen statt symtaktischen Aspekte verlagert werden. 
    Die syntaktischen Aspekte werden von der Entwicklungsumgebung übernommen \cite{10}.
    Die Umsetzung von Programmen erfolgt durch Flussdiagrammen, die vom Benutzer erstellt werden können. 
    Die erstellten Flussdiagramme werden dann vom System interpretiert und ausgeführt \cite{12}.
    Nach Charntaweekhun bieten Flussdiagramme einen didaktischen Vorteil, weil diese Programmieranfängern ermöglichen, komplexe Abläufe visuell zu erfassen und zu strukturieren \cite{12}.
    Ein weiterer Vorteil von VPLs besteht in der erhöhten Lesbarkeit und der geringeren Anfälligkeit für syntaktische Fehler, was auf die Verwendung einer begrenzten Menge vordefinierter grafischer Elemente zurückzuführen ist \cite{10}.
    Die stärken von VPLs zeigen sich darüber hinaus in ihrer Einfachheit, visuelle Darstellbarkeit, Transparenz und Interaktivität \cite{13}.
    %TODO folgende sätze umformilieren
    Die Klassifikation visueller Programmiersprachen unterscheidet zwischen imperativen und deklarativen Modellen. Ersteres gibt die exakte Reihenfolge der Operationen vor, während letzteres lediglich Datenabhänigkgieten spezifiziert und die Ausführungsreihenfolge dem System überlasst \cite{21}.
    Visuelle Programmiersprachen (VPLs) basieren überwiegend auf einem datenflussgesteuerten Modell, bei dem die Strukturierung von Programmen durch den Austausch von Informationen zwischen Operatoren erfolgt. \cite{6}
    Zusammengefasst kann man sagen, dass VPLs die Vorteile von Flussdiagrammen und nicht die Nachteile der klassischen Programmierung kombiniert \cite{13}.\\
    \\
    \textbf{Datenfluss-basierte Sprachen}\\
    \\
    %Punkte von Jonston et. al erklären  und zyklisch/azyklisch
    Als Datenfluss-basierte Sprache (DL) wird eine Programmiersprache verstanden, bei der die Daten zwischen Funktionnen weitergeleitet werden. 
    Die Programme werden dabei als Graphen dargestellt \cite{11}.
    Dieser wird als gerichteter Graph (DG) definiert, in dem Funktionen als Knoten dargestellt werden.
    Die Knoten können dabei durch gerichtete Kanten verbunden werden, welche die Datenabhängigkeiten zwischen zwei Knoten beschreiben \cite{2}.
    Datenflussgraphen lassen sich hinsichtlich ihrer Granularität in feinkörnig und grobkörnig unterteilen. In einem feinkörnigen Graphen führt jeder Knoten extakt eine Instruktions aus, während grobkörnige Graphen mehrere Instruktionen pro Knoten ausführen können \cite{1}.
    Neben der Granularität lässt sich ein Datenflussgraph auch in Zyklenstrukturen unterteilen. 
    Dabei wird zwischen zyklisch und azyklisch unterschieden \cite{8}. %TODO begriffe kurz erklären
    DLs sind überwiegend funktional geprägt, aber können auch text-basiert sein \cite{2}.
    Der Vorteil einer DLs ist, dass diese durch einen Graphen dargestellt werden können \cite{11} und dadurch die Programme einfach zur verstehen sind \cite{6}.
    Für komplexe Programmen kann eine reine Graphendarstellung schnell unübersichtlich werden. Zur Struktuierung komplexer Programme werden Mikrofunktionen eingesetzt, bei denen einzelne Knoten auf untergeordnete Teilgraphen verweisen. Dadurch lassen dann auch rekursive Abläufe modellieren. \cite{11}    
    DLs führen Instruktionen nicht in einer festen Sequenz aus. Dadurch können unabhängig voneinander ausführbare Instruktion parallel verarbeitet werden \cite{1}.
    Diese Form der Ausführung ermöglicht eine Effizienzsteigerung, da der Ablauf nicht mehr durch einen zentralen Programmzähler gesteuert wird \cite{2}.\\
    \\
    Johnston et. al beschreiben in ihrer wissenschaftlichen Arbeiten eine Menge von Grundlegenden Eigenschaften. 
    So sollen DLs frei von Seiteneffekten sein, den Lokalitätsprinzip folgen und keine Variablenüberschreiben zulassen \cite{2}.
    Frei von Seiteneffekten beudetet dabei dass Ausführungen nur von den Eingaben abhängen.
    Das Lokalitätsprinzip besagt, dass bevorzugt auf Speicherbereiche zugegriffen wird, die entweder räumlich nahe beieinanderliegen (räumliche Lokalität) oder innerhalb kurzer Zeit mehrfach verwendet werden (zeitliche Lokalität).\\
    \\
    Eine Computerarchitketur, die auf DLs basiert, wird Datenfluss-basiertes System (DBS) genannt.
    DBSs wurde eingeführt um den Flaschenhals der von-Neumann-Architektur zu vermeiden \cite{8}. %TODO überprüfen ob zittat wirklich von 8 kommt
    Vorteile von DBSs sind eine hohe Effizienz, flexible Strukturen und leistungsstarke Ausführungsmechanismen \cite{1}.
    Darüber hinaus besteht ein weiterer Vorteil im möglichen Paralellismus, da bei fehlender Datenabhängigkeit mehrere Insturktionen gleichzeitig ausgeführt werden können \cite{1}.
    Dies wird durch die direkte Weitergabe von Daten zwischen Funktionen unterstützt, wobei die Verarbeitung Der Daten, wie Transformation und Filterung, innerhalb der Funktionen erfolgt \cite{15}.
    Innerhalb von DBSs wird zwischen daten- und bedarfgetriebener Ausführung unterschieden. 
    Ersteres führt die Funktionen aus, sobald alle Operanden vorhanden sind und ein Signal vorliegt. 
    Hingegen bei der bedarfgetriebenen Ausführung die Funktion ausgeführt wird, sobald alle Operanden vorhanden sind \cite{2}.
    Aus dem Grund kann die datengesteuerte Ausführung als Spezialfall einer bedarfsgesteuerten Ausführung angesehen werden, bei der ein Bedarf an allen Ergebnissen von vorneherein besteht \cite{11}.\\
    \\
    %TODO kurzer vergleich zu von neumann
    %BBS imperativen Programmierablauf, Datenfluss/Kontrollfluss
    %lazy evaluation im zusammenhang mit bedarfgesteuert erklären
    \textbf{Wasserfall Modell}\\
    \\
    %TODO phasen auflisten und erklären, phasen können je nach variation unterscheiden
    Das Wasserfallmodell ist ein Modell für Softwareentwicklung \cite{24} und wurde 1970 eingeführt \cite{25}. 
    Die Softwareentwicklung wird dabei in verschiedene voneinander getrennte Phasen unterteilt \cite{22}.
    Es handelt sich beim Wasserfallmodell um ein statisches Modell, da die einzelnen Phasen linear und sequentiell durchlaufen werden \cite{22}.
    Sobald eine Phase abgeschlossen ist, kann diese nicht wieder besucht werden \cite{22}. 
    Aus dem Grund ist das Modell besonders gut für Systeme geeignet, welche nach der Implementierung keine Änderungen mehr zulassen \cite{22}. 
    Die Vorteile eines Wasserfallmodells sind, dass es einfach verständlich ist \cite{22}, die Anforderungen an das System bereits vor der Entwicklung bekannt sind und es einfach umzusetzen ist \cite{23}.
    Außerdem trägt die Dokumentation am Ende jeder Phase zur Verbesserung der Projektqualität bei \cite{23}.
    Hingegen ein großer Nachteil von Wasserfallmodellen ist, dass sich ändernde Anforderungen oder auftretende Probleme während der Entwicklung nicht berücksichtigt werden können \cite{23}.
    Um den Nachteilen des klassischen Wasserfallmodells etwas entgegenzuwirken haben sich die letzten Jahre einige Varianten entwickelt.
    So beschreibt TODO (24) in seinem Artikel eine Variante, bei der die einzelnen Phasen einer sorgfältigen Validierung und Bestätigung seitens des Clients benötigen um die Phase abzuschließen. 
    Sollte der Client mit dem Ergebnissen nicht zufrieden sein, so kann das Modell wieder von vorne beginnen \cite{24}. 
    In einer anderen Variante wird die Test-Phase komplett weggelassen, da das Testen während der gesamten Entwicklung stattfinden soll \cite{25}.
    \subsection{Domaine}
    %TODO ggf manche blöcke erklären vorallem die später verwendet werden
    Bei dem Programm handelt es sich um einen graphischen Editor der Fahrzeugsystemdaten GmbH (FSD).
    Die FSD erstellt Prüfvorgaben für die Hauptuntersuchung.
    Der Benutzer hat die Möglichkeit per Drag-and-Drop seine Prüfung zusammen zu bauen.
    Dabei stehen dem Benutzer eine vielzahl von vordefinierten Blöcken zur Verfügung.
    In Abbildung TODO ist ein Auszug der fertigen Software abgebildet.
    Zur besseren Verständlichkeit wurde die Abbildung in Teilbereiche unterteilt, welche im folgenden kurz erläutert werden.
    Bereich B umfasst das Canvas, das als interaktive Arbeitsfläche fungiert.
    TODO
    \newpage
    \section{Systemanalyse}
    In diesem Kapitel wird das System hinsichtlich seiner strukturellen und funktionalen Eigenschaften analysiert. 
    Zunächst wird die zugrundeliegende Grammatik betrachtet, woraufhin die Ausführungslogik beschrieben wird. Abschließend werden die problematischen Stellen im Hinblick auf die geplante Erweiterung analysiert.
    Ziel dieses Kapitels ist es, diese problematischen Stellen zu erfassen und aufzubereiten, um eine Grundlage für die folgenden Kapitel zu schaffen.\\
    \subsection{Grammatik}
    %TODO Die in diesem Kapitel definierte Grammatik beinhaltet allerdings nur die für die Ausführungssemantik benötigten Elemente.\cite{99}
    %Die zugrundeliegende Grammatik basiert auf der Backus-Naur-Form (BNF) Notation. Der Aufbau einer BNF wird anhand der Grammatik~\ref{BNF} erklärt
    %<symbol> sind nichtterminale
    %::= bedeutet dass symbol durch _expression_ ersetzt wird
    %_expression_ ist eine sequenze von nichterminalen und terminale
    %Kleene-Stern * wiederholung
    %Alternation \textbar  oder
    %Sequenz erlaubt auch Klammern um die Reihenfolge der Regel zu definieren
    %Softwareprüfung lääst sich visuall von zwei seiten betrachen. 
    %\begin{grammar}
    %    <symbol> ::= _expression_
    %\end{grammar}
    %\textbf{Grammatik TODO} Backus-Naur-Form\\\\\\
    \label{BNF}
    %TODO Grammatik beinhaltet allerdings nur die für die Ausführungssemantik benötigten Elemente. den satz einbauen
    Die Grammatik der domainspezifischen Sprache lässt sich Formal in drei Ebenen unterteilen. 
    Die oberste Ebene ist die Prüfungslogik, die mittlerste Ebene ist die Datenverarbeitung und die letzte Ebene ist das Typsystem. \cite{99}
    Ersteres beschreibt die benötigten Aktionen und Entscheidungen für eine Prüfung. \cite{99}
    Hingegen die Datenverarbeitung für die Definition von Datentranformationen zuständig ist und eine von mehreren Aktionstypen darstellt. \cite{99}
    Im gegensatz dazu kümmert sich das Typsystem um die statische Analyse der Ausführbarkeit der vorangegangen Ebenen. \cite{99}
    %Grammatik lässt sich in 3 Ebenenunterteilen Prüfungslogik, Datenverarbeitung und Typsystem
    %Prüfungslogik führt Entscheidung im Prüfungsablauf aus und bestimmt die Reihenfolge der Aktionen. außerdem datenerfassung
    %Datenverarbeitung ist für die Datentranformation auswertung zustädnig. Also Funktionen, welche keine Nebeneffekte besitzen, weil sie unabhängig von der restoichen Softwareprüfung stattfinden.
    %Typsystem ermöglicht die statische analyse der ausführbarkeit
    %Softwareprüfung lääst sich visuall von zwei seiten betrachen. 
    %Einmal als Datenflussgraphen, indem Teil-Funktionen als Blöcke dargestellt werden und Funktionsparamter/Ergebnisse als Ports.
    %Einmal als Aktivitätsdiagramm, in dem nur Startzustand, Endzustände, Aktions- und Entscheidungsblöcke dargestellt.
    %Die folgende Zusammenfassung basiert auf der unveröffentlichen Arbeit von Westermann et al.
    \subsubsection{Prüfungslogik}
    Die in Abbildung \ref{Aktivitätsmodell} abgebildeten Regeln beschreiben das Aktivitätsmodell, die der Prüfungslogik entspricht. \cite{99}
    Zentral ist dabei die Regel \textit{ActivityModel}, welche festlegt, dass ein Aktivitätsmodell aus mehreren Aktivitäten und Verbindungen besteht.
    Die Verbindung referenziert dabei zwei Aktivitäten und hat auch eine Bezeichnung, die als TODO.
    Die Regel \textit{Activity} beschreibt die möglichen Aktivitäten innerhalb des Aktivitätsmodells. 
    Dabei kann eine Aktivität entweder eine Startmarkierung, eine Entscheidung, eine Aktion oder ein Label sein.
    
    Eine Entscheidung kann dabei ein Binärentscheidung oder ein Validierungsentscheidung sein.
    Ersteres besteht dabei aus einer Referenz auf ein Flowtemplate, das eine Datenverarbetung ist, gefolgt von einem Operator und zwei Argumenten. 
    Als Operatoren stehen $=$ und $\neq$ sowie Relationale Operatoren zur Verfügung.
    Die Validierungsentscheidung hingegen besteht nur aus einer Menge von Werten, die entweder TODO.

    Bei den Aktionen wird zwischen Hauptunsersuchungs-Adpater Anfragen, lesen von JSON-Dateien und Ausführung einer Datenverarbeitung unterschieden.
    Der Aufbau einer Hauptuntersuchungs-Adapter Anfrage umfasst dabei den Namen der auszuführenden Anfrage, eine Beschreibung, eine Liste mit anzusprechenden Systemen im Fahrzeug und eine maximale Ausführungsdauer.
    Im Gegensatz dazu setzt sich das lesen von JSON-Dateien aus dem Datentyp der zu lesenden Datei und einer URI zu der Datenquelle zusammen.
    Die letzte Aktionform, die Ausführung einer Datenverarbeitung, besteht aus einem Verweis auf einem FlowTemplate, gefolgt von einer Beschreibung der Eingaben, die für die Datenverarbeitung erforderlich sind, sowie einer Transformation, die beschreibt wie das Ergebnis weiterverwendet werden soll.    
    Die Beschreibung der Eingaben setzt sich dabei aus den Symbolen ActivityPortValue und TemplateParameterValue zusammen.

    Die Struktur eines Label wird durch eine Kombination aus einer Beschriftung, einer Farbe und einem Verweis auf eine Aktion beschrieben.\\
    %Die Regel $<ActivityModel>$ beschreibt die Grundstruktur des Aktivitätsmodell und setzt sich aus $<Acitvity>$ und $<ActivityConnection>$ zusammen. 
    %$<Acitvity>$ sind dabei Aktivitäten und kann entweder eine Startmakierung ($<ActivityStart>$), ein Vergleich ($<ActivityCondition>$), eine Aktion ($<ActivityAction>$) oder ein Label ($<ActivityDisplay>$) sein.
    %$<ActivityConnection>$ hingegen definiert, welche Aktivtäten miteinander verbunden sind und setzt sich aus zwei Aktivitäten (ref(Acitvity source) und ref(Acitvity target)) und einer Beschriftung für die Kante ($<string label>$)
    %Eine Aktion kann dabei eine der folgenden Aktionen sein:
    %\begin{itemize}
    %    \item Senden von Hauptuntersuchungs-Adatper-Anfragen (A1) $<ActivityPitaBuildInforRequest>$
    %    \item Lesen einer JSON Datei (A2) $<ActivityLoadExternalData>$
    %    \item Ausführung einer Datenverarbeitung (A3) $<ActivityFlowCall>$
    %\end{itemize}
    %$<ActivityFlowCall>$ setzt sich aus einem Flow-Template (ref(FlowTemplate)), mehreren Eingaben ($<ActivityPortValue>$ und $<TemplateParameterValue>$) und mehreren Transformationen ($<ValueTranformation>$).
    %Die Transformation beschreibt dabei wie das Ergebnis der Datenverarbeitung weiter genutzt werden soll.
    %Auf die Bedetung des Flow-Templates und der TemplateParameterValue wird im verlaufe des Kapitel eingegangen
    %$<FlowPortValue>$ setzt sich aus einer Reihe von primtiven Typen ($<FlowPortValue>$) oder einem verweis auf einer Aktion mit einer Transformation ($<ActivityPortValue>$) zusammen.
    %$<ActivityPitaBuildInforRequest>$ uns $<ActivityLoadExternalData>$ setzen sich nur aus Eingaben vom primtiven Typ zusammen, welche für die Ausführung des zwecks notwendig sind zusammen.
    %Der Vergleich kann etweder ein Binärvergleich $<ActivityBinaryCondition>$ oder ein Validierungsvergleich $<ActivityValidityCondition>$ sein.
    %Der Binärvergleich setzt sich dabei aus einem Flow-Template, einem Operator ($〈ActivityBinaryConditionOperator〉$) und zwei Eingaben ($<ActivityPortValue right>$ und $<ActivityPortValue left>$) zusammen.
    %Das Label kann sich dabei aus mehreren Textfeldern ($〈ActivityDisplayField〉$) zusammen. Ein Textfeld besteht dabei aus einer Beschriftung ($〈string label〉$), einer Farbe ($〈string color〉$) und einem Verweis auf eine Aktion (ref(ActivityAction))

    %Das Aktivitätsmodell  $<ActivityModel>$ besteht aus einer Reihe von Aktivitäten $<Activity>$.
    %Aktivitäten können dabei entweder eine Startmarkierung, eine Aktivitätsaktion, einem Vergleich oder visualles Label sein.
    %Die Startmarkierung muss pro Prüfungslogik genau einmal vorkommen.
    %$<ValueTransformation>$ beschreibt wie das Ergebnis der Datenverarbeitung weiter genutzt werden sollen
    %Ein vergleich kann dabei entweder eine Binärentscheidung oder eine Validierungsentscheidung sein.   
    %Die Validierungsentscheidung $<ActivityValidityCondition>$ nimmt als Eingabe einen Wert und überprüft ob diese Werte vorhanden sind.
    %Die Binärentscheidung $<ActivityBinaryCondition>$ nimmt als Parameter zweite Werte, einen Vergleichoperatur und eine referenz zu einer Funtkion. Dabei werden beide Werte als Eingabe für die referenzierte Funktion verwendet.
    %Als Vergleichoperatoren stehen $=$ und $\neq$ sowie Relationale Operatoren zur verfügung.
    %Eine Aktivitätaktion <ActivityAction> kann dabei einer der folgenden Aktionen ausführen:
    %Bevor das Ergbeniss aus der vorherigen Aktionsaktivität verwendet wird, kann eine Transformation auf dieses Ergebniss angewendet werden.

    %A1 nimmt als Parameter den Namen der auszuführenden Anfrage, eine Beschreibung für den debugger, eine Liste von anzusprechnenden System im Fahrzeig und die maximale Zeitdrauer einer Anfrage.
    %A2 nimmt als Eingabe den Typ der zu ladenenden Datei und die dazugehörige URI.
    %A3
    \begin{figure}[H]
        \begin{grammar}
            <ActivityModel> ::= <Activity>* <ActivityConnection>

            <Activity> ::= <ActivityStart>
            | <ActivityAction>
            | <ActivityCondition>
            | <ActivityDisplay>

            <ActivityConnection> ::= ref(Activity source) <string label> ref(Activity target)

            <ActivityStart> ::= $\epsilon$

            <ActivityAction> ::= <ActivityFlowCall>
            | <ActivityPitaBuildInforRequest>
            | <ActivityLoadExternalData>

            <ActivityFlowCall> ::= ref(FlowTemplate) <ActivityPortValue>* <TemplateParameterValue>* <ValueTransformation>*

            <ActivityPitaBuildInforRequest> ::= <string abdFilename> <string requestAlias> <string expectedSystems>* <number timeout>

            <ActivityLoadExternalData> ::= <Type dataType> <string dataSource>

            <ActivityPortValue> ::= <FlowPortValue>
            | <ActivityPortRefernce>

            <FlowPortValue> ::= <string>
            | <number>
            | <bool>
            | <date>
            | <FlowPortValue>*

            <ActivityPortRefernce> ::= ref(ActivityAction) (ValueTransformation)*

            <ValueTransformation> ::= <string objectReference>
            | <number listIndex>

            <ActivityCondition> ::= <ActivityBinaryCondition>
            | <ActivityValidityCondition>

            <ActivityBinaryCondition> ::= ref(FlowTemplate) <ActivityBinaryConditionOperator> <ActivityPortValue left> <ActivityPortValue right>

            <ActivityValidityCondition> ::= <ActivityPortValue>*

            <ActivityBinaryConditionOperator> ::= '='
            | '$\neq$' 
            | '\textless' 
            | '$\leq$' 
            | '\textgreater' 
            | '$\geq$'

            <ActivityDisplay> ::= <ActivityDisplayField>*

            <ActivityDisplayField> ::= <string label> <string color> ref(ActivityAction)
        \end{grammar}
        \caption{Aktivitätsmodell}
        \label{Aktivitätsmodell}
    \end{figure}    
    \newpage
    \subsubsection{Datenverarbeitung}
    %Eingabe <FlowInputPort> und Ausgabe $<FlowOutputPort>$
    %Funktionen höherer Ordnung $<FlowLamda>$
    %Eine Funktion höher Ordnung besteht aus zustzälciehn Eingabe- und Ausgabeports
    %Eingabe- und Ausgabeports nehmen als Parameter einen Namen des Ports, den Typ und ob Fehlererlaub ist.

    %Ein Funktions Template $<FlowTemplate>$ besteht aus einer Funktion $Flow$ und belieg vielen Parametern $<TemplateParameter>$
    %Die Parameter generieren Port- und Lambda-Defintion
    %Funktionen welche vom Autorensystem $<LibraryFlow>$ und selbst definierte Funktionen $<FlowModel>$

    %Ein Flow-Modell ist ein DAG bei dem mehrere Funktionen mitienander verbunden werden. Einzelne Funktionen werden Nodes $<FlowNode>$ genannt.
    %Das Flow-Modell wird durch eine $<FlowInstance>$, Reihe von Funktionen und Verbidnugen definiert.
    %Die Funktion kann dabei eine Eingabe <$FlowNodeInput>$, eine Ausgabe $<FlowNodeOutput>$, einer Lambda Referenz $<FlowNodeLambda>$ oder eine Funtkions Referenz $FlowNodeFlowCall$
    %Konstante Werte $FlowPortValue$
    %TODO erklären was ist lamba?
    %Die Flow-Instanz ($〈FlowInstance〉$) kann als Funktion interpretiert werden und bildet eine oder mehrere Eingaben ($〈FlowOutputPort lambdaArguments〉$) auf eine oder mehrere Ausgaben ($〈FlowOutputPort  lambdaArguments〉$) ab.
    %Zusätzlich kann die Flow-Instanz aus einer oder mehreren Lamda-Definitionen ($〈FlowLamda〉$) beinhalten. Eine Lamda-Definition hat zusätzliche Eingaben und Ausgaben.
    %Die Ein- und Ausgaben bestehen dabei einem Namen  ($〈string name〉$) , gefolgt vom Typ  ($〈Typ〉$)  und einem boolean  ($〈bool acceptsError〉$) , welcher angibt ob Fehler akzeptiert werden oder nicht.\\
    Die in Abbildung \ref{Flow-Instanz} dargestellten Regeln definieren die Struktur einer Flow-Instanz. Dabei kann eine Flow-Instanz als konkreten Aufruf einer Funktion interpretiert werden. 
    Die Regel \textit{FlowInstance} legt dabei fest, dass eine Flow-Instanz aus mehreren Eingabe- und Ausgabeports sowie einer Menge von Funktionen höherer Ordnung besteht.
    Der Aufbau einer Funktion höherer Ordnung umfasst wiederum zusätzliche Eingabe- und Ausgabeports.
    Ein Port besteht aus einem Namen, gefolgt vom Datentyp des Ports und einem Wahrheitswert der Angibt ob an diesem Port Fehler erlaubt sind.\\
    \begin{figure}[H]
        \begin{grammar}
            <FlowInstance> ::= <FlowOutputPort lambdaArguments>* <FlowInputPort lambdaArguments>* <FlowLambda>*
            
            <FlowLambda> ::= <FlowOutputPort lambdaArguments>* <FlowInputPort lambdaArguments>*

            <FlowInputPort> ::= <string name> <Type> <bool acceptsError>

            <FlowOutputPort> ::= <string name> <Type> <bool producesError>
        \end{grammar}
        \caption{Flow-Instanz}
        \label{Flow-Instanz}
    \end{figure}
    %Ein Flow-Template ($〈FlowTemplate〉$) kann als abstrakte Oberklasse angesehen werden und besteht dabei aus einer Funktion ($〈Flow〉$) gefolgt von keiner oder mehreren Template-Parametern ($〈TemplateParameter〉$), welche Port- und Lambda-Definitionen generien können.
    %Eine Funktion kann dabei eine vom System bereitgestellte ($〈LibraryFlow〉$) oder eine vom Benutzer selbst definierte ($〈FlowModel〉$) sein.\\
    Ein Flow-Template wird durch die in Abbildung \ref{Flow-Template} spezifierten Regeln beschrieben.
    Das Flow-Template wird dabei durch eine Funktion \textit{Flow} und eine Menge von TemplateParametern definiert. 
    Bei den TemplateParameter wird zwischen einer Zeichenkette, Zahlen oder einem Wahrheitswert unterschieden. 
    Diese Parameter beeinflussen die automatische Generierung der Port-Struktur sowie der internen Verarbeitungslogik eines Flows. \cite{99}
    Die Funktionen lassen sich in vordefinierte \textit{LibraryFlow} und eigene erstellten Funktionen \textit{FlowModel} unterteilen.\\
    \begin{figure}[H]
        \begin{grammar}
            <FlowTemplate> ::= <Flow> <TemplateParameter>*

            <Flow> ::= <LibraryFlow> | <FlowModel>
            
            <LibraryFlow> ::= $\epsilon$

            <TemplateParameter> ::= 'String' | 'Number' | 'Bool' | <TemplateParameterList>
            
            <TemplateParameterList> ::= <TemplateParameter>
        \end{grammar}
        \caption{Flow-Template}
        \label{Flow-Template}
    \end{figure}
    %Die vom System bereitgestellte Funktionen lassen sich dabei in eine von sieben Kategorien unterteilen: Hauptuntersuchungs-Adapter-Antworten, Zeichenkettenverarbeitung, Datum, Vergleichoperatoren, Konverter, Operatoren und Listenverarbeitung.\\\\
    %Das Flow-Model ($〈FlowModel〉$) ist, wie bereits erwähnt, die vom Benutzer selbst definierten Funktionen und besteht aus einer Flow-Instanz, gefolgt von mehreren möglichen Funktionen ($〈FlowNode〉$) und Verbindungen ($〈FlowConnection〉$).
    %Flow-Instanz bestimmt die Ein- und Ausgaben des Flow-Models.
    %kann dabei eine $〈FlowNodeOutput〉$, $〈FlowNodeInput〉$, $〈FlowNodeLambda〉$ oder ein $〈FlowNodeFlowCall〉$ sein.
    %$〈FlowNodeInput〉$ besteht aus einem Verweis an einem Verweis an einer Portdefinition, gefolgt von $〈FlowPortValue〉$. Hingegen $〈FlowNodeOutput〉$ nur aus einer Portdefinition besteht.
    %Die $〈FlowConnection〉$ wird durch zwei Verweise definiert.
    %$〈FlowPortValue〉$ bietet dabei die Möglichekit konstante Werte an die Eingabeports anzulegen.
    Die Regeln des Flow-Model sind in Abbildung \ref{Flow-Modell} formal dargestellt. Das FlowModel entspricht dabei der Datenverarbeitung. \cite{99}
    Durch die Regel \textit{FlowModel} wird bestimmt, dass ein FlowModel aus einer FlowInstance, einer Auflistung alle genutzen Flow-Node und definition der Verbindungen zwischen den Eingabe- und Ausgabeports.
    Bei den Flow-Node wird zwischen Verweis auf Eingabeports, Verweis auf Lambda-Funktionen, Verweis auf Funktion mit Auflistung von Parametern oder verweis auf Ausgabeports unterschieden.
    Bis auf das letztere haben alle Flow-Node die Möglichkeit ihre Eingabeports durch konstante Werte zu spezifizieren.
    Flow-Nodes sind Funktionen die innerhalb eines Flow-Modells genutzt werden.\\
    \begin{figure}[H]
        \begin{grammar}
            <FlowModel> ::= <FlowInstance> <FlowNode>* <FlowConnection>*

            <FlowNode> ::= <FlowNodeOutput> | <FlowNodeInput> | <FlowNodeLambda> | <FlowNodeFlowCall>
        
            <FlowNodeOutput> ::= ref(FlowOutputPort)

            <FlowNodeInput> ::= ref(FlowInputPort) <FlowPortValue>

            <FlowNodeLambda> ::= ref(FlowLambda) <FlowPortValue>*

            <FlowNodeFlowCall> ::= ref(FlowTemplate) <FlowPortValue>* <TemplateParameterValue>*
        
            <FlowConnection> ::= ref(FlowOutputPort source) ref(FlowOutputPort target)
        
            <TemplateParameterValue> ::= <string> | <number> | <bool> | <TemplateParameterValueList>
        
            <TemplateParameterValueList> ::= <TemplateParameterValue>*
        \end{grammar}
        \caption{Flow-Modell}
        \label{Flow-Modell}
    \end{figure}
    \subsubsection{Typsystem}
    In Abbildung \ref{Typsystem} werden die Regeln des Typsystem dargestellt.
    Das Typsystem unterstützt Primitive- und Generische-Datentypen, welche an einen Optional-, Listen- oder Objekt-Typen gekapselt werden können.
    Als Primtiven-Datentypen stehen \textbf{String}, \textbf{Number}, \textbf{Bool}, \textbf{Data} und \textbf{PtiaResponse} zur Auswahl.
    Ersteres ist eine Datumsanagbe. Hingegen PtiaResponse die Antwort von einem Hauptunsersuchungs-Anfrage ist.\\
    \begin{figure}[H]
        \begin{grammar}
            <Type> ::= <TypePrimtive> | <TypeOptional> | <TypeList> | <TypeObject>

            <TypePrimtive> ::= 'String' | 'Number' | 'Bool' | 'Data' | 'PtiaResponse'
            
            <TypeOptional> ::= <Type> '?'
            
            <TypeList> ::= <Type> '[]'
            
            <TypeObject> ::= '\{' (<string key> ':' <Type>)* '\}'

            <TypeGeneric> ::= '\$' <string genericName>

            <TypeReference> ::= ref(Type)
        \end{grammar}
        \caption{Typ-Definition mit gernrischen und Referenz-Typen}
        \label{Typsystem}
    \end{figure}
    \subsection{Ausführung}
    Im folgenden Unterkapitel wird gezeigt, wie die einzelnen Ebenen ausgeführt werden.
    Die folgende Zusammenfassung basiert auf der Arbeit von Westermann et al.\\
    \\
    \textbf{Prüfungslogik}\\
    \\
    Die Prüfungslogik stellt die oberste Ebene einer Prüfung dar und wird als Kontrollfluss modelliert.
    Als Startpunkt jeder Prüfung fungiert die Startaktivität, die pro Prüfung nur einmal vorkommen darf.
    Die Reihenfolge der auszuführenden Aktivitäten wird durch die soeben ausgeführte Aktivitäte vorgegeben, da jede Aktivität das Label der zu folgende Kante als Rückgabewert zurückgibt.
    Eine Prüfung ist beendet, sobald die auszuführende Aktivität kein Label mehr zurückgibt.\\
    \\
    Ein wichtiger Bestandteil der Prüfungslogik ist der \textbf{Referenzstack}. Der Referenzstack dient als Speicher für die Ergebnisse der Aktivitäten.
    Alle Aktivitäten können auf den Referenzstack zugreifen und die gespeicherten Ergebnisse referenzieren, um diese als Parameter für ihre Funktionen zu verwenden.\\
    %Ein wichtiger Bestandteil der Prüfungslogik ist der Referenzstack. Der Referenzstack beeinhaltet alle Erge.
    %Die Aktivitäten können auf den Referenzstack zugreifen und abgespeicherte Ergebnisse referenzieren und diese als Parameter für ihre Aktionen verwenden.
    %Der Startpunkt jeder Prüfung ist die Startaktivität. Die Startaktivität darf pro Prüfung nur einmal vorkommen und ist dafür zuständig, dass der Referenzstack leer ist.
    %Die Reihenfolge der auszuführenden Aktivitäten wird durch die Aktivitäten vorgegeben. Die Aktiväten geben nämlich das Label der nächst zu folgenden Kante zurück. 
    %Die Prüfungs ist beendet, sobald die Aktivität kein Label mehr zurückgibt.\\
    \\
    \textbf{Datenverarbeitung}\\
    \\
    %einfügen,dass nach pull-ansatz gearbeitet wird
    %funktion zuständig für die berechnung der ausgabeports
    Die Ausführung der Datenverarbeitung basiert auf einer Execute-Funktion, die zur ausführung die Template-Parameter und eine Evaluate-Funktion benötigt.
    Für die vom System bereitgestellten Funktionen wird die Execute-Funktion direkt in den Code implentiert. 
    Die Implementierung nutzt dabei eine Hilfsklasse, die die Evaluate-Funktion bereitstellt und gleichzeitig die Werte der Ausgabeports speichert.
    Zudem muss die Implementierung sicherstellen, dass der Datenfluss zwischen Eingabe- und Ausgabeports korrekt hergestellt wird. 
    Um dies zu gewährleisten, stellt die Klasse RuntimeContext gewisse Hilfsmethoden zur Verfügung.
    Eine wichtige Komponente der Datenverarbeitung ist der Ergebniscache. 
    Im Ergebniscache werden die Werte der Ausgabeports gespeichert.
    Wird ein Wert für einen Eingabeport benötigt, so wird zunächst nach dem zugehörigem InputNode sowie der entsprechenden eingehen Kante gesucht. 
    Anschließend wird geprüft, ob für den Ausgabeport, der mit der Kante verbunden ist, ein Wert im Ergebniscache vorliegt.
    Ist dies nicht der Fall, wird die Funktion des Knotens ausgeführt und der Wert für den Ausgabeport im Ergebniscache gespeichert.\\
    Nicht nur für die normalen Funktion spielt der Ergebniscache eine große Rolle, sondern auch für die Lambda-Funktionen.
    Wenn ein Wert für einen Eingabeport einer Lambda-Funktion benötigt wird, wird zunächst der Wert des Ausgabeports, falls vorhanden, in dem Ergebniscache gespeichert.
    Im Anschluss daran wird für alle Funktionen, die im Kind-verhältnis zur Lambda-Funktion stehen, das Ergebnis im Ergebniscache invalidiert, indem das Ergenis aus dem Ergebniscache gelöscht wird.
    Anschließend wird der oben beschriebene Algortihmus verwendet, um die Werte für die Eingabeport der Lambda-Funktion zu berechnen.\\
    \\
    \textbf{TypSystem}\\
    \\
    Bevor die Typvalidierung bei Flow-Modells vorgenommen werden kann, muss bei dem Modell zunächst die Flow-Templates in die konkrete Flow-Instanz überführt werden. 
    Anschließend werden die Verbindungen als Objektreferenzen geändert. 
    Das daraus entstandene Modell wird \textbf{Graph-Form} genannt und wird für die Analyse verwendet.
    Bei der Graph-Form werden zuerst die Referenztypen durch konrekte Typen ersetzt. 
    Nachdem die ersetzung Abgeschlossen ist, wird sich um die generischen Typen gekümmert. 
    Dafür werden zunächst die Flow-Modelle topoloisch sortiert und pro Flow-Modelle über alle Verbindungen iteriert. 
    Kommt bei einem Port ein generischer Typ vor wird die Typzuweisung gespeichert. 
    Es wird probiert über die anderen Typzuweisungen die generischen Typen aufzulösen. 
    Sobald dies erledigt ist, wird die Zuweisungskompatibilität der einzelnen Verbindungen überprüft. 
    Als letztes kann das Modell dann auf Port-Fehler überprüft werden. 
    Hierfür werden zunächst die Flow-Node topologisch sortiert, sodass Abhängigkeiten einer Flow-Node vor der Flow-Node validiert werden. 
    Bei der Validierung für für jede Flow-Node jedes Argument und dessen Verbindung untersucht. 
    Bei der untersuchung wird geschaut, ob das Attribut acceptsError des dazugehörigen Eingabeports den gleichen Wert hat wie der Ausgabeport. 
    Ist dies nicht der Fall wird eine Fehlermeldung für diesen Flow-Modell ausgegeben. 
    Dabei wird die Fehlermeldung durch alle Flow-Nodes weitergeleitet bis sie am Ausgabeport des Flow-Modells anliegt.\\
    \\
    Zur Validierung des Aktivitätsmodell wird ein Typen-Referenzstack verwendet.
    Bei der Validierung wird durch alle Aktivitäten iteriert und für jede Aktivität der Typen-Referenzstack berechnet.
    Berechnet wird der Referenzstack durch den Schnitt aller Typen-Referenzstack vorhergehenden Aktivitäten.
    Je nachdem welche Aktivität gerade ausgeführt wird, wird der Referenzstack bearbeitet.
    Bei einer Aktionsaktivität wird der Referenzstack durch einen Eintrag erweitert.
    Hingegen bei einer Entscheidungsaktivität Typen im Referenzstack bearbeitet werden können.

    %Um zu überprüfen ob das Aktivitätsmodell valide ist, wird ein Typen-Referenzstack verwendet.
    %Dabei wird das ganze Modell durchlaufen und für jede Aktivität der Stack berechnet.
    %Bei der Berechnung wird die Schnittmenge über den Referenzstack der direkten Vorgänger Aktivitäten gebildet.
    %Im Anschluss wird der Stack durch die auszuführende Aktivität erweitert.
    %Zum Beispiel erweitert eine Aktionsaktivtät den Stack um einen Typen. 
    %Hingegen Entscheidungsaktivität Einträge bearbeiten oder präzisieren können. Beispielweise werden bei einer erfolgreichen Validierungsentscheidung die betroffenden Typen im Stack konkretisiert. Dadurch sollen die Optionalen-Typ entfernt werden.
    %Im Anschluss können dann die Nodes validiert werden. 
    %Bei der Validierung wird geprüft ob das Argument $〈bool acceptsError〉$ der $〈FlowNodeInput〉$ den gleichen Wert wie der Refenzierte $〈FlowInputPort〉$ hat. Ist das nicht der Fall wird eine Fehlermeldung für das Flow-Modell ausgegeben.
    \subsection{Codeanalyse}
    \label{Codeanalyse}
        Die aktuelle Umsetzung des Codes ermöglicht es aktuell nicht die geplante. Konkret lassen sich zwei Probleme aus der aktuellen Umsetzung ableiten:
        \begin{itemize}
            %\item Beim Validieren des Graphens wird überprüft, ob Zyklen vorliegen. Sollten Zyklen vorliegen werden error erzeugt.
            %\item Bei der umwandlung in einen ausführbaren Code werden alle Knoten des Graphens zu einer Funktion zusammengefasst. Bei Verzweigungen werden neue Funktionen erstellt. Bei einer Zusammenführung werden die einzelnen Funktionen gemergt.
            \item P1 Die Modellanalyse erlaubt keine Zyklen im Graphen
            \item P2 
        \end{itemize}
        \textbf{P1 - Die Modellanalyse erlaubt keine Zylken}\\
        \\
        Aktuell wird in der Klasse ActivityCycleCheckResolver überprüft, ob im Graphen Zyklen vorhanden sind. 
        Die Überprüfung erfolgt dabei mithilfe des TODO Algorithmus.
        Der Algorithmus markiert zueerst in einem Dictonairy alle Knoten des Graphen als nicht besucht. 
        Anschließend wird eine Tiefensuche über alle Knoten gemacht und jeder Knoten wird in eine Liste hinzugefügt. 
        Dabei werden die nachfolgenden Knoten zunächst der Liste hinzugefügt. 
        Dadurch erfolgt ein topologisches Sortieren der einzelnen Knoten.
        Auf der topolischen sortierten Liste wird dann eine erneute Tiefensuche durchgeführt, die für jeden erreichbaren Knoten einen Eintrag mit der gemeinsamen Wurzel (root) erstellt. 
        Dabei werden die Einträge als erstes für alle Vorgänger Knoten erstellt.
        Nun wurden alle zusammenhängende Elemente des Graphens gefunden und die zusammenhängende Elemente können in einem Dictonairy übertragen werden. 
        Dabei wird der root der Schlüssel des Dictonairy Elements sein und der Value der Knoten. %TODO
        Hat ein Dictonairy Element mehr als ein Element im Value ist ein Zyklus vorhanden und dieses Element wird dann in einem anderen Dictonairy gespeichert, welches zum erstellen von Fehlermeldungen verwendet wird.
        Aber dies ist auch das Problem. 
        Es zeigt, wenn ein Zyklus erlaubt ist, darf das zugehörige Key-Value-Paar nicht im das Dictonairy für die Fehlermeldung gespeichert werden, sondern dieser Schritt muss übersprunen werden.\\
        \\
        \textbf{P2 - bereits ausgefürte Funktionen können nicht erneut ausgeführt werden}\\
        \\
        %if(_visitedActivityElements.Add(elementIdNotNull) is false)
        Die Klasse \textit{VirtualMachine} verhindert aktuell, dass Blöcke mehrmals aufgerufen werden.
        Dies geschieht indem für alle auszuführende Blöcke ein Eintrag in einer Liste vom Datentyp Bool angelegt wird.
        Jeder Eintrag hat standardmäßig den Wert false. 
        Wird ein Block nun ausgeführt, wird der dazugehörige Wert in der Liste auf true gesetzt.
        Bevor eine Funktion ei Block ausgeführt wird, wird geschaut, welcher Wert in Liste ist.
        Ist dies der Fall, wird der Block übersprungen und mit der nächsten auszuführenden Funktion weitergemacht.
        Hingegen beim Wert false die Funktion der Klasse VirtualMachineCounter hinzugefügt wird.
        Dort liegt auch das Problem.
        TODO
        %TODO: Beim betrachen der Klasse VirtualMachineCompilerActivity, die für das kompilieren der Aktivitäten zuständig ist, ist aufgefallen, dass dort ein Fehler vorliegt.
    \newpage
    \section{Anforderungs- und Entwurfsphase}
    In dem Kapitel werden die ersten zwei Phasen des Wasserfallmodells für die geplante Erweiterung beschrieben. 
    Als Wasserfallmodell wird der in Kapitel \ref{Terminologie} beschriebene modifizierte Ansatz von Patela et al. verwendet.
    \subsection{Anforderungen}
    In diesem Unterkapitel wird die Anforderungphase beschrieben.
    In der Anfordeurngsphase werden die benötigten Anforderungen an die Blöcke identifiziert und erläutert. \cite{24}\\
    \\
    Die geplante Erweiterung sieht die Einführung von zwei Schleifenblöcken vor, die die Wiederholung von Aktivitäten ermöglichen sollen. 
    Dadurch soll es möglich sein Prüfungen mit dynamsichen Daten verarbeiten zu können.
    %TODO kommenden zwei zeilen besser formulieren
    %Beide Blöcke (Block A und Block B) sollen vom Aufbau gleich sein.
    Der einzige Unterschied ist, wie der Algorithmus die Schleife ausführen will.
    Der Benutzer soll die Möglichkeit haben per Drag-and-Drop den Schleifenblock aus einer Liste auszuwählen und diesen frei im Canvas platzieren zu können.
    Sobald der Block platziert wurden ist, kann der Benutzer mit dem Schleifenblock interargieren.
    Die Schleifenlogik soll durch den Benutzer konfigurierbar sein. 
    %die Anazahl der Iterationen und die Abbruchbedingung für die Schleife festzulegen.
    %Zusätzlich stehen Anzeigeooptionen zur verfügung.
    %Die Abbruchbedingung setzt sich dabei aus zwei Feldern für die Argumente und einer Auswahlsliste für den Operator zusammen.
    Dafür wird auf die bereits vorhandene grafische Benutzeroberfläche des Systems zurück gegriffen.
    %Am Block selbst kann der Benutzer die Verbindungen erstellen, indem er per Drag&Drop die einzelnen Interaktionspunkte verschiedener Aktvitäten verbindet.
    %Rückverbindungen über den Schleifenblock sollen dabei erlaubt sein.
    %Ingesammt stehen dem Schleifenblock vier Interaktionspunkte zur Verfügung.
    %Welcher Pfad genommen wird, wird durch den Wahrheitswert der Abbruchbedingung bestimmt.
    \subsection{Entwurf}
    Im folgenden Unterkapitel wird die Entwursphase beschrieben.
    In der Entwurfsphase werden die Anfoderungen aus der Anfoderungsphase konkretisiert, unter anderem durch das entwerfen von Algorithmen. \cite{24}
    \textbf{Schleifenblock}\\
    \\
    Für die Integration der neuen Schleifenblöcke ist eine Anpassung der Grammatik der Prüfungslogik erforderlich, konkret an der Regel \textit{Activity}.    
    Hier muss die Regel um eine Alternative erweitert werden, die ein neues Nichterminale einführt.
    Das Nichtterminal \textit{ActivityLoop} kann dabei \textbf{SchleifeA} oder \textbf{SchleifeB} sein.
    Beide Varianten setzen sich dabei aus einem ganzzahligen Wert für die Anzahl der Iterationen und einer Abbruchbedingung zusammen.
    Die Abbruchbedingung wird durch das Nichtterminalsymbol \textit{ActivityBinaryCondition} abgebildet.
    Die entsprechende Regel für das Nichterminal wurde bereits definiert.
    Dargestellt wird die Erweiterung in Abbildung \ref{Erweiterung Prüfungslogik}.
    Auch in diesem Fall beinhaltet die Erweiterung nur die für die Ausführungssemantik benötigten Elemente.\\
    \begin{figure}[H]
        \begin{grammar}
            <Activity> ::= <ActivityStart>
            | <ActivityAction>
            | <ActivityCondition>
            | <ActivityDisplay>
            | <ActivityLoop>

            <ActivityLoop> ::= <integer iteration> <ActivityBinaryCondition>

            <ActivityBinaryCondition> ::= ref(FlowTemplate) <ActivityBinaryConditionOperator> <ActivityPortValue left> <ActivityPortValue right>

            <ActivityBinaryConditionOperator> ::= '='
            | '$\neq$' 
            | '\textless' 
            | '$\leq$' 
            | '\textgreater' 
            | '$\geq$'
        \end{grammar}
        \caption{Erweiterung Prüfungslogik}
        \label{Erweiterung Prüfungslogik}
    \end{figure}
    \noindent
    Der Schleifenblock soll dabei als Oval im Canvas dargestellt werden.
    Beim Klicken auf den Schleifenblock soll der Benutzer die Möglichkeit haben die Anazahl der Iterationen und die Abbruchbedingung für die Schleife festzulegen.
    Zusätzlich TODO.
    Die Abbruchbedingung setzt sich dabei aus zwei Feldern für die Argumente und einer Auswahlsliste für den Operator zusammen.
    Am Block selbst kann der Benutzer die Verbindungen erstellen, indem er per Drag-and-Drop die einzelnen Interaktionspunkte verschiedener Aktvitäten verbindet.
    Rückverbindungen über den Schleifenblock sollen dabei erlaubt sein.
    Ingesammt stehen dem Schleifenblock vier Interaktionspunkte zur Verfügung.
    Welcher Pfad genommen wird, wird durch den Wahrheitswert der Abbruchbedingung bestimmt.
    Ist die Abbruchbedingung Wahr, wird die Verbindung untem vom Interaktionspunkt (OnTrue) genommen.
    Wenn hingegen die Abbruchbedingung Falsch ist, wird die Verbindung rechts vom Interaktionspunkt (OnFalse) genommen.\\
    \\
    \textbf{Block A}\\
    \\
    %TODO funktionsweise des schleifenblocks allgemein erklären
    Block A soll die Wiederholung von Aktivitäten durch explizite Ausführung ermöglichen und wird durch SchleifeB abgebildet.
    Das soll geschehen indem die Schleife durch eine verschachtelte if-Anweisung ersetzt wird.
    Zur Umsetzung dieses Ziels wird die \textbf{Schleifenentfaltung} als Grundlage verwendet.
    Unter Schleifenentfaltung versteht man, dass die Instruktione in der Schleife mehrmals pro Iteration auszuausgeführt werden, um dadurch die Häufigkeit der Iterationen zu verringern \cite{9}.
    Um das Ziel zu erreichen, muss die Schleifenentfaltung abgeändert werden.
    Die Schleifenentfaltung soll nicht nur die Häufigkeit der Iterationen reduzieren, sondern diese vollständig eliminieren.
    Da die maximale Anzahl an Iterationen von vorneherein bekannt ist, kann für jede potenzielle Iteration eine Kopie des Schleifenkörper erstellt werden. 
    Am Ende jeder Kopie muss dann noch die Abbruchbedingung drangehangen werden, da diese TODO.
    Als nächstes müssen die einzelnen Kopien miteinander verbunden werden.
    Dies wird erreicht indem von der ersten Aktvität einer Kopie eine Verbindung zur vorangegangenen Schleifenblock hergestellt wird.
    Graphisch wird dieser Ansatz in Abbildung TODO dargestellt.\\
    \\
    %Anstatt rekursive oder iterative Wiederholungen zu verwenden, wird jede potenzielle Iteration als eigenständiger und bedingter Codeblock realisiert.
    %Dazu muss eine Anpassung an der klasisschen Schleifenentfaltungsverfahren vorgenommen werden. 
    %Das Ziel der modifizierung ist es, die Schleifen solange zusammenzufassen bis kein erneuter Schleifendurchlauf notwendig ist und dadurch den Kontrollfluss durch Verzweigungen und verschtelungen ohne Iterationen abzubilden.
    %Da die maximale Anzahl an Schleifendurchläufen von vorneherein bekannt ist, kann für jede potenzielle Ausführen des Schleifenkörpers eine Kopie erstellt werden. 
    %In jeder Kopie wird der Schleifenkörper ausgeführt und anschließend um die Abbruchbedingung der Schleife ergänzt. Im Falle einer erfüllten Abbruchbedingung wird hingegen keine weitere Kopie ausgeführt. 
    %Stattdessen wird die Ausführung gemäß dem vorgesehenen Kontrollfluss fortgesetzt.
    %Auf Abbildung TODO wurde der Ansatz Graphisch dargestellt.
    %In Abbildung TODO wird dieser Ansatz an einem konkreten Beispiel veranschaulicht.
    %Im Beispiel soll "foo" drei mal einzeln auf der Console ausgegeben werden. 
    %In der oberen Schleife
    %Hingegen in der unteren Schleife der modifizierte Ansatz verwendet wurden ist. Da die untere Schleife nur noch genau einmal ausgefürt wird, kann diese einfach weggelassen werden.\\
    \\
    \textbf{Block B}\\
    \\
    Block B soll die Wiederholung von Aktivitäten durch iterative Schleifen ermöglichen und wird durch SchleifeA abgebildet.
    Zur umsetzung dieses Ziels wird ein Mittelwertansatz als Grundlage verwendet.
    Wird die OnFalse Verbindung des Schleifenblocks ausgewählt wird als erstes überprüft, ob eine Wiederholung stattfinden darf oder nicht.
    Dafür wird geschaut, ob die Anzahl an Interationen bereits das maximum erreicht haben oder der Chancen-Zähler den Wert 0 erreicht hat.
    Sind beide Bedingungen nicht erfüllt, ist eine Wiederholung erlaubt wird TODO.
    Dabei wird das erste Argument aus der Abbruchbedingung genommen und versucht in einen Gleitkommawert umgewandelt. %TODO
    Dafür wird das Argument als erstes in eine Zeichenkette umgewandelt und anschließend versucht als Gleitkommazahl zu interpretieren.
    Ist dies Möglich, wird die die Gleitkommazahl in eine Liste mit allen bisherigen umgewandelten Argumenten gespeichert.
    Schlägt die Interpretation fehl, ist das Argument keine Zahl gewesen und die Zeichenkette muss mithilfe von UTF-8 in eine Dezimalzahl umgewandelt werden.
    Bei der Umwandlung wird die Zeichenkette zeichenweise in die entsprechende Dezimalzahl umgewandelt und anschließend mit ihren Index multipliziert.
    Im Anschluss werden die einzelnen Zahlen addiert, sodass am Ende nur noch eine Summe übrig bleibt.
    Die Summe wird anschließend in eine Gleitkommazahl umgewandelt und der Liste hinzugefügt.
    In Abbildung TODO wird die Rechnung für ein Beispiel durchgegangen.
    Basierend auf der Liste mit allen bisherigen umgewandelten Argumenten wird dann ein Mittelwert über alle Werte gebildet und ein gleitender Mittelwert über die letzen 3 Werte.
    Anschließend wird die Differenz zwischen dem aktuellsten Wert und den Mittelwerten berechnet. 
    Ist die Differenz kleiner als ein Threshold wird der Chancen-Zähler dekremntiert. 
    Anderfalls wird der Chancen-Zähler zurückgesetzt.
    Der Chancen-Zähler ist erforderlich, weil dieser als Steuermechanismus für die Wiederholungslogik dient und eine Begrenzung der Iterationen bei ausbleibender signifikanter Veränderung sicherstellt.
    Sollten weniger als 3 Werte in der Liste enthalten sein, wird die Berechnung der Differenz übersprungen und direkt mit der Wiederholung der Aktivitäten begonnen.
    Dadurch kann gewährleistret werden, dass das System einlaufen kann und die Mittelwerte erst gebildet werden, wenn eine aussagekräftige Datenbasis vorhanden ist.\\
    \\
    %Erreicht der Chancen-Zähler 0 werden keine weiteren Wiederholungen ausgeführt, da der wert sehr wahrscheinlich stagniert.
    %Dadurch soll verhindert werden, dass eine ineffiziente Fortsetzung der Schleife stattfindet.
    %Ist die Abbruchbedingung nicht erfüllt, wird Entschieden ob eine Wiederholung stattfindet oder nicht. Dabei wird geschaut wie sich das dynamische Datum über die Iteration hinweg verhält.
    %Es wird überprüft, ob die Anzahl der Iterationen bereits die maximale Anzahl an Iteration überschritten hat oder der Chancen-Zähler den Wert 0 erreicht hat.
    %Da der Vergleich auf Mittelwerten basiert, müssen die Eingaben in einen Gleitkommawert umgewandelt werden.
    %Zunächst wird dafür die Eingabe in eine Zeichenkette umgewandelt und anschließend versucht als Gleitkommazahlen zu interpretieren. 
    %Schlägt die Interpretation fehl, handelt es sich nicht um eine Zahl. In dem Fall muss die Zeichenkette zeichenweise mithilfe von UTF-8 in eine Dezimalzhal überführt werden.     
    %UTF-8 bietet sich zur Umwandlung an, da es bereits eine eindeutige und standardisierte Codierung für über 1,1 Millionen Unicode-Zeichen bereitstellt und somit keine zusätzliche Festlegung eines eigenen Codierungsschemas erforderlich ist.    
    %Die einzelnen Zahlen werden dann mit ihren Index multipliziert und im anschluss addiert.
    %Der Schritt mit der multiplizierung ist notwendig, weil die addtion kommutativ ist und somit keine berücksichtigung der Zeichenfolge erfolgt, wird durch Multiplikation mit der Zeichenposition eine positionsabhängige Gewichtung sichergestellt.
    %Die Werte vom Typ double werden anschließend in einer Liste gespeichert, die alle bisherigen Eingaben beinhaltet.
    %Basierend auf dieser Liste wird dann ein Mittelwert über alle bisherigen Werte gebildet und ein gleitender Mittelwert über die letzen 3 Werte.
    %Anschließend wird die differenz zwischen den aktuellen Wert und den Mittelwerten gebildet. ist die differenz kleiner als ein threshold wird der counter dekremntiert. ist die differenz gleich oder größer als der Threshold wird der Chancen-Zähler zurückgesetzt.
    %Erreicht der Chancen-Zähler 0 werden keine weiteren Wiederholungen ausgeführt, da der wert sehr wahrscheinlich stagniert.
    %Der Chancen-Zähler erweist sich als erforderlich, da dieser als Steuermechanismus für die Wiederholungslogik dient und eine Begrenzung der Iterationen bei ausbleibender signifikanter Veränderung sicherstellt.
    %Dadurch soll verhindert werden, dass eine ineffiziente Fortsetzung der Schleife stattfindet.
    %Sollten weniger als 3 Werte in der Ergbenissliste drin sein, wird die Berechnung übersprungen. Dadurch kann gewährleistret werden, dass das System einlaufen kann und die Mittelwerte erst gebildet werden, wenn eine aussagekräftige Datenbasis vorhanden ist.\\
    \\
    Auf die Vor- und Nachteile der einzelnen Blöcke wird im Kapitel \ref{Evaluation} eingegangen.

    \newpage
    \section{Implementierungsphase}
    In diesem Kapitel wird die Implementierungsphase beschrieben. 
    Dabei werden die in der Entwurfsphase erarbeiteten Konzepte in das System implementiert. \cite{24}
    Im Folgenden werden die vorgenommenen Änderungen am Quellcode beschrieben und erläutert.\\
    \\
    %TODO eigenschaft durch attribute ersetzen
    Zunächst wurde Klasse DataModelActivityElement um das Attribute \textit{CanCreateLoop} vom Datentyp bool erweitert. 
    Bei dieser Klasse handelt es sich um die Basisklasse aller Aktivitäten.
    Das Attribut soll als Kennzeichnung dienen, um anzuzeigen ob der Benutzer die Möglichkeit hat von dem Block ausgehend eine Rückverbindung einzuzeichnen. 
    Aus dem Grund ist das Attribut für alle Aktivitäten bis auf die SchleifeA und SchleifeB false. \par
    Da das System keine Schleifen am Anfang unterstützt hat, musste für die Schleife eine Klasse erstellt werden.
    Bei der Klasse handelt es sich um \textit{DataModelActivityElementLoop}, die als Grundlage für die Datenspeicherung und für die Ausführung genutzt wird.
    %TODO klasse nochmals anschauen; änderungen sind geplant
    Der Klasse stehen zwei Variablen für die Ausgänge und eine Variable für die Anzahl der Iterationen. 
    Für die Variablen stehen jeweils noch getter und setter als Methoden zur verfügung, damit die Werte gesetzt und ausgelesen werden können.
    Zusätzlich stehen der Klasse durch die Vererbung die Methoden und Variablen der Basisklasse DataModelActivityElement zur verfgügung.
    Die Klasse ActivityPortLabels, die die Label für die Ports beinhaltet, wurden durch die strings \textbf{OnLoop} und \textbf{OnFinish} erweitert.
    OnLoop ist dabei der OnFalse Interaktionspunkt und Onfinish der OnTrue Interaktionspunkt. \par
    Eine weitere Änderung wurde an der Klasse \textit{VirtualMachineCompilerActivity} vorgenommen.
    %TODO ab hier
    \textit{VirtualMachineCompilerActivity} ist zuständig für die Kompilierung der Aktivitäten. 
    Dafür wird von jeder Aktivität ein Objekt mit allen benötigten Informationen zur Ausführung (Statement) erstellt.
    Da für SchleifeA und SchleifeB noch keine Möglichkeit besteht Statements zu erstellen, müssen Änderungen an den bestehende Methoden vorgenommen werden.
    Bei der Methode \textit{CreateActivityFunctions()} muss die Switch-Anweisung um zwei weitere Fälle erweitert werden.
    Da SchleifeA und SchleifeB Verzweigungsblöcke sind, muss der dritte Paramter der Methode auf true gesetzt werden, damit für beiden Schleifen ein eigener Funktionsblock erstellt wird.
    Dieses Statements werden dann in der Klasse \textit{VirtualMachineActivity} ausgeführt.
    Die in diesem Absatz beschriebenen Änderungen wurden durch Westermann implementiert.\\
    \\
    %Block A
    Zur umsetzung der Wiederholungslogik im Block A wurde eine Klasse definiert.
    Dabei handelt es sich um die Klasse ActivityLoopUnrollingResolver.
    Ziel der Klasse ist es Schleifen zu identifizieren und diese durch den in Kapitel TODO beschriebenen Algorithmus aufzulösen.
    Zur Umsetzung dieser Funktionalität hat die Klasse sieben Methoden UnrollLoop, getLoopActivities, visited, getLoopElements, cloneAndModify, DeepClone und clone.\\
    \\
    Der Startpunkt für den Algorithmus ist die Methode \textit{UnrollLoop()}.
    Diese Methode hat das Ziel, den Schleifenanfang und das Schleifenende zu bestimmen. 
    Außerdem leitet \textit{UnrollLoop()} die Schleifenentfaltung ein.
    Dafür stehen der Methode die Liste aller Elemente und zwei Variablen für den Schleifenanfang und das Schleifenende, die jeweils das konkrete Element speichern, zur verfügung.
    Um die beiden Variablen zu konkretisieren, wird zuerst über die Liste iteratiert und nachdem Element gesucht mit dem Attribute classType = "LoopB".  %Ist das der Fall, ist dieses Element das Schleifenende und wir in die zugehörige Variable gespeichert.
    Wurde ein Element gefunden, wird dieses in die Variable für das Schleifenende gespeichert.
    Um den Schleifenanfang zu finden, kann das Schleifenende verwendet werden.
    Mithilfe des Attributes OnFinishedSuccessor kann die Id des Schleifenanfangs herausgefunden werden und genutzt werden um das kronkete Element zu bekommen.
    Dafür wird erneut über die Liste der Elemente iterariert und jede Id mit der Id des Schleifenanfang verglichen.
    Sobald eine eine übereinstimmung gefunden wurden ist, wird dieses Element abgespeichert. 
    Wenn die beiden Variablen bestimmt und nicht Null sind, kann die Methode \textit{getLoopElements()} aufgerufen werden.\\
    \\
    \textit{getLoopElements()} 
    %Das Ziel der Methode getLoopActivities ist es die Rahmenbedingung für die Tiefensuche zu schaffen.
    %Die Methode stellt dafür ein Set für die gefunden Verbindungen, einem Tupel, welches die Rückverbindung darstellt und einer Variable, die die Id des Schleifenanfangs beinhaltet bereit.
    \\
    \\
    TODO
    Die Methode \textit{visit()} führt eine rekursive Tiefensuche ab dem Schleifenanfang im Graphen durch.
    Dabei wird jeder Knoten aus einem HashSet hinzugefügt und für jeden nachfolgenden Knoten \textit{visit()} erneut aufgerufen.
    Die Ausnahme dabei ist dabei das Schleifenende.
    Handelt es sich bei dem nachfolgenden Knoten um das Schleifenende, wird das Schleifenende dem HashSet hinzugefügt, aber \textit{visit()} wird nicht für dieses Element aufgerufen.
    Das hat dem Grund, da die nachfolgenden Knoten ab dem Schleifenende irrelevant für den Algorithmus sind.\\
    \\
    Die Hilfemethode clone TODO ist für das Klonen der Elemente zustädnig. Dazu wird das übermittelte TODO in serialisiert und anschließend deserialisiert.
    Die beiden Methoden werden von der Klasse JsonSerializer bereitgestellt
    Durch die Deserialiserung entsteht eine exakte Kopie vom übermittelten TODO.
    Als Rückgabewert der Hilfsmethode wird das kopierte Objekt zurückgegeben.\\
    \\
    Die Methode \textit{cloneAndModify()} ist für die organsierung des Klonvorgangs zuständig.
    Um dies zu realisieren steht der Methode ein HashSet für die geklonten Elemente zur verfügung.
    Zunächst wird über das HashSet mit allen Elementen aus der Schleife iteratiert.
    Für jedes Element wird mithilfe von \textit{clone()} eine exakte Kopie erstellt.
    Die Kopie wird anschließend der Kopie des Datamodells angehangen und daraufhin einer neuem HashSet hinzugefügt.
    Das neu erstellte HashSet dient als Parameter für den rekursiven Aufruf und beeinhaltet nur die Kopien.
    Sobald die Iteration abgeschlossen ist, wird überprüft ob die Anzahl der Iteration bereits kleiner ist als zwei.
    Ist das der Fall wird Zähler für die Anzahl der Iterationen um eins verringert und \textit{cloneAndModify()} erneut aufgerufen.\\
    \\
    Die letzte Methode ist clone.
    Das Ziel dieser Methode ist die Erstellung der Kopie und änderungen an dieser vorzunehmen.
    Dafür wird als erstes überprüft, um welche Aktivität es sich bei dem übergebenen Element genau handelt.
    Sobald dies feststeht, wird eine Kopie mithilfe der Methode DeepClone erstellt.
    Anschließend wird die Id des kopierten Objekts um einen Suffix erweitert.
    Als nächstes werden die Verbindungen überprüft. 
    Existiert eine Verbindung wird diese auch um den gleichen Suffix erweitert.
    Die Ausnahme dafür bilden die Verbindungen des Schleifenblocks.
    Hier wird an der Verbindung, die aus der Schleife führt, keine Änderung vorgenommen, weil an den Verbindungen nachdem Schleifenrumpf keine Veränderungen vorgenommen werden.
    Und die eigentliche Rückverbindung muss auf das erste Elemente der Kopie verweisen. 
    Dafür muss die Verbindung des Urbilds geändert werden.
    Anders gesagt, das Suffix muss an die Verbindung des Urbilds drangehangen werden statt an der Kopie.
    Durch das anhängen des Suffix wird eine eindeutige TODO geschaffen, außerdem bleibt die ursprüngliche Struktur des Schleifenrumpf erhalten.\\
    \\ 
    %TODO parameter erwähnen ja oder oder nein?
    %Die Funktionalität der Klasse wird durch die drei Methoden calcute, calculateMean und isDeviationWithinThreshold realisiert.
    %Block B
    Zur umsetzung der Wiederholungslogik im Block B wurden vier Klassen \textit{DeviationChecker}, \textit{Counter}, \textit{StringToDoubleConverter} und \textit{InputProcessor} definiert.
    Die Klasse \textit{DeviationChecker}, die in Abbildung TODO dargestellt ist, hat das Ziel den Mittelwert zu berechnen und die Differenz zum aktuellen Wert auf ihren Schwellenwertüberschreitung hin zu überprüft.
    Zur Umsetzung dieser Funktionalität hat DeviationChecker eine Mittelwert-Variable vom Datentyp Double sowie die drei Methoden \textit{calcute}, \textit{calculateMean} und \textit{isDeviationWithinThreshold}.\\
    \\
    Die Methode \textit{calculateMean()} übernimmt die Berechnung des aktuellen Mittelwerts, indem über die Liste der Eingaben iteriert wird und diese aufsummiert werden.
    Der berechnete Summenwert wird durch TODO geteilt und anschließend als Rückgabewert zurückgegeben.\\
    Mithilfe der Methode \textit{isDeviationWithinThreshold()} wird die Differenz berechnet und überprüft ob die Differenz den Schwellenwert unterschreitet.
    Dies erfolgt durch die Berechnung des Betrags der Differenz zwischen Mittelwert und dem aktuellen Wert.
    Je nach Ergebnis wird dann ein entsprechender Wahrheitswert zurückgegeben.\\
    Der Ablauf der Klasse wird in der Methode \textit{calculate()} gesteuert. Hier wird zunächst überprüft, ob die anderen Methoden aufgerufen werden soll.
    Der Algorithmus wird lediglich bei Vorhandensein von mindestens drei Werten in der Eingabeliste gestartet.
    Ist dies der Fall wird \textit{calculateMean()} aufgerufen und dessen Rückgabewert in die Mittelwert-Variable gespeichert.
    Im Anschluss erfolgt der Aufruf von \textit{isDeviationWithinThreshold()}, dessen Rückgabewert von \textit{calculate()} zurückgegeben wird.\\
    \\
    Ein andere Klasse ist \textit{Counter}.
    Diese dient der Verwaltung zweier Zählerwerte: chance und counter.
    Der Zugriff auf diese Variablen erfolgt nach dem Prinzip der Datenkapslung.
    Zur Funktionalität stehen Methoden zum Verrigern (\textit{decreaseChance()} und \textit{decreaseCounter()}), Zurücksetzen (\textit{resetChance()}) sowie Setzen und Auslesen (\textit{setCounter()}, \textit{getCounter()}, \textit{getChance()}) der Zählerwerte zur Verfügung.\\
    \\
    Mit der Klasse \textit{StringToDoubleConverter} wird ein String in einen Double-Wert umgewandelt.
    Um dies zu ermöglichen stellt die Klasse verschiedene Variable zur verfügung, darunter eine Variable für den Zähler der Schleife, einen für die Bytes und einen für den umgewandelten Wert.
    Die Methode StringToDouble konviert die Zeichenkette, indem sie zunächst die Zeichenkette in UTF-8 kodierte Bytes umgewandelt.
    Anschließend werden die Bytes mit einem fortlaufenden Index multipliziert und auf einen Akkumulator addiert.
    Der akkumulierte Wert wird im Anschluss als Rückgabewert zurückgegeben.\\
    \\
    Die letzte der vier Klassen ist \textit{InputProcessor}.
    Diese ist für die Verarbeitung der Eingabewerte zuständig.
    Zur Verarbeitung stehen mehrere interne Datenstrukturen und konstanten zur verfügung, darunter zwei Listen zur Speicherung der Roh- und Konvertierungswerte sowie Parameter zur Konfiguration (HistoryLength und deviationThreshold) und eine Instanz der Klasse Counter.
    Die Methode processInput übernimmt TODO und überprüft zunächst ob eine weitere Verarbeitung zulässig ist. 
    Als Kriterium dafür wird der aktuelle Stand der Klasse Counter herangezogen.
    Ist eine weiter verarbeitung zulässig wird zuerst TODO und der Eingabewert mithilfe der Methode storeInput in eine Liste gespeichert.
    Anschließend wird der Eigabewert mit der Methode convertInputToDouble in einen Double-Wert konvertiert.
    Dieser Wert wird nach der Konvertierung dann in eine Liste gespeichert.
    Im Anschluss daran wird mithilfe der Methode validateDeviation der konvertierte Wert auf eine mögliche Abweichung hin überprüft.
    Als letzter Schritt der Verarbeitung wird der Zähler dekrementiert.\\
    \\
    Die Methode convertInputToDouble TODO. Ist dies nicht möglich, wird der Eingabewert mit der Methode StringToDouble aus der Klasse StringToDoubleConverter in einen Double-Wert konviert.
    Als Rückgabewert wird der Double zurückgeben.\\
    \\
    Mithilfe der Methode validateDeviation wird überprüft, ob der Eingabewert eine signifikate Abweichung im Vergleich zur Historie aufweist.
    Dafür wird zunächst der Index des letzten Elements aus der Liste bestimmt und anschließend die Abweichungsberechnung über die Methode calcute der Klasse DeviationChecker durchgeführt.
    Liegt eine signifikante Abweichung vor wird der Zähler resetet. Ist hingegen keine Abweichung vorhanden wird der Zähler dekremntiert.\\
    \\
    Um Zyklen in der Prüfung zu erlauben, ist eine Anpassung der Zyklenprüfung erforderlich.
    Die Funktionsweise der Zyklenprüfung wurde bereits im Unterkapitel \ref{Codeanalyse} beschrieben.
    Eine Änderung muss am Anfang der Methode \textit{ComponentAnalysis()} vorgenommen werden.
    Hier muss bei der Iteration über alle Elemente jede Id in ein Set gespeichert werden, das ein Schleifenblock ist.
    Die andere Änderung muss in der Methode \textit{AssignToComponent()} erfolgen.
    Konkret an der Stelle an der über die Vorgängerelemente iteriert wird.
    Dort müssen vor dem reksuriven Methoden Aufruf zwei Bedingungen überprüft werden.
    Erstens ob das Vorgängerelement ein Schleifenblock ist.
    Dies geschieht, indem geschaut wird, ob die Id des Vorgängerelements in dem Set vorkommt. 
    Wenn dies der Fall ist, handelt es sich bei dem Vorgängerelement um einen Schleifenblock.
    Zweitens ob das Element und das Vorgängerelement die gleichen Elemente sind.
    Dies kann überprüft werden indem die beiden Elemente auf gleichheit überprüft werden.
    Wenn beide Bedingungen erfüllt sind, handelt es sich um die Rückverbindung der Schleife. 
    In diesem Fall darf die Methode \textit{AssignToComponent()} nicht aufgerufen werden, sondern muss übersprungen werden.
    Wenn die Methode nicht übersprungen wird, wird die Verbindung in das Dictionary aufgenommen, was im späteren Verlauf des Algorithmus zu einem Fehler führen würde.
    Durch diese beiden Änderungen ist es nun möglich, ausgehende Schleifen vom Schleifenblock aus zu erzeugen, ohne dass ein Fehler entsteht.
    Ausgehende Schleifen von anderen Aktivitäten aus sind weiterhin nicht erlaubt.
    %\subsection{1. Lösungsansatz}
    %Schleife soll durch ein Schleifenkonstruktor dargestellt werden.
    %Prüfungslogik muss eine weitere Aktivitätsaktion erweitert werden. Das Schleifenkonstrukt greift dabei auf bereits vorhandene Regeln der Prüfungslogik zu.
    %Das Schleifenkonstrukt greift dabei wie die anderen Aktivitätsaktionen auf den Referenzstack zu. Da der nächste Schleifendurchlauf nicht wieder auf den gleichen Eingabenwerten laufen soll, da diese wieder zu einem fehlerhaften Wert führen wird, muss ein Mechanismus im Schleifenkonstrukt implementiert werden, welcher einen neuen Wert holt.
    %Der Schleifenkörper wird dabei nicht mithilfe von Rekursion oder Iteration ausgeführt, sondern durch entfaltung. 
    %Ye et al. beschreiben Schleifenentfaltung als eine gängige Methode um Compiler zu optimieren, weil mit dieser Methode die mehreren Schleifendurchläufe zu einer zusammengefasst werden. \cite{9}
    %Huang et al. beschreiben den ALgortithmus wie folgt TODO.
    %Der beschrieben Ansatz kann für unseren Ansatz nicht 1:1 übernohmen werden, sondern muss etwas modifiziert werden. Unser Ziel ist es nicht nur einzelene Schleifendurchläufe zusammen zu fassen, sondern die ganzen Schleifendurchläufe in einer einzigen zusammenzufassen.
    %Da bei unseren Lösungsansatz die maximale Anzahl an Schleifendurchläufen begrenzt ist und diese bereits vor der Ausführung der Prüfungs bekannt ist, kann diese Information beim modifizierten Ansatz berücksichtigt werden. Ein Beispiel in in Abbildung TODO.
    %Bei dem Beispiel ist die Anzahl der Schleifen Durchläufe auf 3 begrenzt. In beiden Schleifen soll die Zeichenkette "Foo" 3-mal auf der Konsole ausgegeben werden. 
    %Der Schleifenkopf initalisiert am Anfang eine Variable. Anschließend wird eine Abbruchbedigung definiert und im Anschluss die veränderung der Variable pro Schleifendurchlauf festgelegt.
    %Im Beispiel 1 wird die Funtkion console.log("Foo") pro Schleifendurchlauf einmal ausgeführt.
    %Hingegen im Beispiel 2 wurde die Schleife entfaltet und die Funktion console.log("Foo") pro Schleifendurchlauf 3-mal ausgeführt. Da die Schleife aber nur noch einmal ausführt und dann abbricht, kann diese auch weggelassen werden.
    %Zwischen den einzelnen Funktionen muss dafür gesorgt werden, dass die neue Wert zur verfgügung steht. Deswegen ist die Idee alle bisherigen Aktivitätaktion zu wiederholen, damit der aktuellste Wert vom Hauptuntersuchungs-Adapter ausgelesen wird und die Prüfung aufgrundlage dieses Wertes nochmals ausgefürt wird. Ein Beispiel ist in Abbildung TODO.
    %\VerbatimInput[numbers=left]{schleifen.js}
    %\textbf{Abbildung TODO}\\
    %Der Benutzer gibt von vorneherein eine Zahl a an, welche die maximale Anzahl von Schleifendurchläufe beschränkt. Für die Zahl muss dafür folgendes gelten TODO.
    %Die Idee des Ansatzes ist es, den Schleifenköper nicht Iterativ oder Rekursiv ausführen, sondern a-mal auszurollen.
    %Dafür wird der Schleifenköper und die nachfolgenden Anweisungen a-mal kopiert. Die Schleife wird dadurch nicht dynmasisch ausgeführt, sondern statisch in den Code implementiert. Dadurch entstehen $a+1$ Graphen. Jeder dieser Graphen repräsentiert einen ursprüngliche Iteration. Dabei werden die einzelnen Graphen mit ihren direkten Nachbaran verbunden. 
    %Da die aktuell zugrunde liegende Implementierung determenistisch ist und aktuell nur auf die gleiche Eingabe zugegriffen werden kann, muss ein Mechanismus implementiert werden, welcher den aktuellen Sensorwert ausliest und diesen an die nachfolgenden Anweisungen weitergibt. Dieser Vorgang muss für jede neu eingefügte Verbindung wiederolt werden.
    %\resizebox*{!}{10cm}{
    %\begin{tikzpicture}[]
        %\node[state, initial text=""](q5){};
        %\node[state, rectangle, below = 1cm of q5](q6){Aktion1};
        %\node[state, rectangle, below = 1cm of q6](q7){Aktion2};
        %\node[state, below = 1cm of q7](q8){Entscheidung};
        %\node[state, rectangle, accepting, below = 1cm of q8](q9){Ausgabe};

        %\node[state, rectangle, right = 2cm of q6](q10){Aktion1};
        %\node[state, rectangle, right = 2cm of q7](q11){Aktion2};
        %\node[state, below = 1cm of q11](q12){Entscheidung};
        %\node[state, rectangle, accepting, below = 1cm of q12](q13){Ausgabe};

        %\node[state, rectangle, right = 2cm of q10](q14){Aktion1};
        %\node[state, rectangle, right = 2cm of q11](q15){Aktion2};
        %\node[state, below = 1cm of q15](q16){Entscheidung};
        %\node[state, rectangle, accepting, below = 1cm of q16](q17){Ausgabe};

        %\draw(q5) edge[->] (q6);
        %\draw(q6) edge[->] (q7);
        %\draw(q7) edge[->] (q8);
        %\draw(q8) edge[->] (q9);
        %\draw(q8) edge[->] (q10);
        
        %\draw(q10) edge[->] (q11);
        %\draw(q11) edge[->] (q12);
        %\draw(q12) edge[->] (q13);
        %\draw(q12) edge[->] (q14);

        %\draw(q14) edge[->] (q15);
        %\draw(q15) edge[->] (q16);
        %\draw(q16) edge[->] (q17);


    %\end{tikzpicture}
    %}\\
    %\textbf{Abbildung TODO}\\
    %\subsection{2. Lösungsansatz}
    %Schleife soll durch ein Konstrukt realisiert werden.
    %Prüfungslogik muss um eine weitere Aktivitätsaktion erweitert werden. Das Schleifenkonstrukt greift dabei auf bereits vorhandene Regeln der Prüfungslogik zu.
    %Das Schleifenkonstrukt greift dabei wie die anderen Aktivitätsaktionen auf den Referenzstack zu. Da der nächste Schleifendurchlauf nicht wieder auf den gleichen Eingabenwerten laufen soll, da diese wieder zu einem fehlerhaften Wert führen wird, muss ein Mechanismus im Schleifenkonstrukt implementiert werden, welcher einen neuen Wert holt.
    %Durch die einführung der Schleife entstehen neue Herausforderungen. Es können nun Endlosschleifen entstehen, welche dazuführen dass die ausgeführte Prüfung niemals terminieren wird. Außerdem liefert der Hauptuntersuchungs-Adapter keine linearen Werte (?), sondern nicht determenistische Werte.

    %Eine Endlosschleife kann von vorneherein ausgeschlossen werden, indem die maximalen Schleifendurchläufe begrenzt werden. 
    %Da die Werte des Hauptuntersuchungs-Adapter nicht vorhersehbar sind und die Prüfung nicht jedes mal die maximale Anzahl der Schleifendurchläufe ausführen soll, muss ein Algorithmus entwickelt werden, welcher sagt wann man davon ausgehen kann, wann die ausgelesenen Sensorwerte sicht großartig nicht mehr ändern und stabil sind.
    
    %Ein möglicher Lösungsvorschlag könnte nun folgendermaßen aussehen. 
    %Je nachdem welcher Typ der Eingabewert hat verläuft der Algorithmus anders. Es wird dabei nur zwischen Zahlen und Zeichenketten unterschieden. 
    %Bei Zeichenketten wird der aktuelle Wert mit dem Wert aus dem vorherigen Schleifendurchlauf verglichen. Dafür wird die Levenshtein-Distanz verwendet. Für die ersten beiden Schelifendurchläufe wird der Algorithmus übersprungen, weil die Levenshtein-Distanz noch kein Aussagekräftiges Ergebnis für den Anwendungsfall geben kann.
    %Die Levenshtein-Distanz gibt die ähnlichkeit zwischen zwei Zeichenketten als Zahl an, indem sie die minimale Anzahl an Operation angibt, welche benötigt werden, damit die erste Zeichenkette der zweiten Zeichenkette gleicht. Je größer die Zahl ist destso "unterschiedlicher" sind die beiden Zeichenketten von einander. 

    %Um zu schauen wie sich die Eingabe zu verschiedenen Zeiträumen verhält, berechnen wir Mittelwerte über TODO. Es sollten mindestens zwei Mittelwerte gebildet werden. Mehr als zwei Mittelwerte sind möglich, aber würden den Algorithmus entwindlicher machen. Der erste Mittelwert sollte über alle bisherigen Eingaben gebildet werden, um zu sehen wie sich die Eingabe auf langer Sicht verhält. Der zweite Mittelwert sollte über die letzten n Eingaben gebildert, um zu sehen wie sich die Eingabe auf kurzer Sicht verhält.
    %Da die Werte der Levenshtein-Distanz sich für den Mittelwert nicht besonders anbieten, müssen die Zeichenketten in einen Zahlenwert umgewandelt werden.hließend Addieren. Für die Umwandlung eignet sich UTF-8 besonders gut. Da UTF-8 fast akke Schriftzeichen weltweit beinhaltet.
    %Das kann geschaffen werden indem alle Zeichen der Zeichenkette in eine eindeutige Zahl umwandeln und die einzelnen Zahlen ansc
    %Zusätzlich muss eine Gewichtung bei der Addition berücksichtigt werden, weil sonst Zeichenketten, die aus den gleichen Zeichen bestehen, den gleichen Wert bei der Addition rausbekommen. Das liegt daran, dass bei der Addition ohne Gewichtung nur die Wertigkeit der einzelnen Zeichen betrachtet wird, aber nicht deren Position. Dieses Problem wird mit der Gewichtung aufgelöst. Ein Beispiel dafür für die Addition mit Gewichtung ist in Abbildung TODO.
    %Dies muss aber nicht für jedes Eingabepaar gemacht werden, sondern nur für Eingabepaare welche sich sehr ähneln, also eine niedrige Levenshtein-Distanz haben. Für Eingabepaare mit einer hohen Levenshtein-Distanz ist das nicht notwendig, weil wir da bereits wissen, dass sich die Zeichketten stark von einerander unterscheiden.
    %Ist die Differenz aus der umgewandelten umgewandelten Zeichenkette und einem Mittel kleiner als ein vordefinierter Schwellenwert, wissen wir dass die Zeichenkette sich nur ganz leicht von den durchschnittlichen Eingaben unterscheidet.
    %Wenn dies nun mehrmals nacheinander vorkommt, kann davon ausgegangen werden, dass der Wert in diesen Wertebereich stagniert.
    %Um dies im ALgortithmus auch zu berücksichtigen, wird ein n-Chance Mechanismus eingebaut der folgendermaßen Funktioniert:
    %\begin{itemize}
        %\item Wird der Schwellenwert unterschritten, wird unser n dekrementiert.
        %\item Wird der Schwellwert übertroffen oder ist unsere Differenz gleich wird n zurückgesetzt.
        %\item Erreicht n irgendwann die 0 wird die Schleife abgebrochen. 
    %\end{itemize}
    %Beispiel
    %$
        %"foo" = 102 + 111 + 111 = 324
        %"oof" = 111 + 111 + 102 = 324
        %mit Gewichtung
        %"foo" = 1 * 102 + 2 * 111 + 3 * 111 = 657
        %"oof" = 1 * 111 + 2 * 111 + 3 * 102 = 639
    %$
    %\\\textbf{Abbildung TODO} Beispiel Addition mit und ohne Gewichtung
    %\\\\Ist unser Eingabewert nun keine Zeichenkette, sondern eine Zahl entfällt der Umwandlungsschritt mit der Gewichtung. Es kann sofort mit den beschriebenen Mittelwertansatz angefangen werden.
    %Schleifenkonstrukt -> Benutzer gibt Abbruchbedigung ein (Benutzer verwendet Schleifenkonstrukt statt Entscheidungs Aktivität) -> 
    %typ (generisch?, damit das System dies für uns übernimmt) der eingabe muss bestimmt werden, damit richtiger algorithmus zur stabilität überprüfung ausgewählt werden kann (es wird nur zwischen zeichenketten und zahlen unterschieden => bei zahlen wird mittelwertansatz gewählt bei zeichenketten Levenshtein-Distanz)
    %Was muss geändert werden: Prüfungslogik muss durch die aktivität schleife erweitert werden
    %Schluss
    \newpage
    \section{Evaluation}
    \label{Evaluation}
    in diesen Kapitel werden die Ergebnisse der durchgeführten Tests beschrieben.
    Dafür wird am Anfang das zu auszuführende System definiert und im anschluss die verschiedenen Szenarionen mit welchen das System getestet wurden ist.
    Am Ende werden die Ergebnisse interpretiert und ein Fazit gezogen.\\
    \\
    Das Programm wurde auf einem System mit einem AMD Ryzen 5 2600 mit 6 Kernen und einer Taktrate 3400MHz ausgeführt. Als Arbeitsspeicher waren 2-Mal 8GB DDR4 mit einer DRAM Frequenz von 1065 MHz eingebaut. 
    Als Betriebssystem ist Windows 10 in der Version 10.0.19045 Build 19045 installiert. Als Laufzeitumgebung wurde .Net 8 einesetzt.\\
    \\
    Zum messen der Ausführungszeit wurde die Klasse Stopwatch verwendet, die eine Menge an Methoden und Eigenschaften bereitstellt um verstrichene Zeit zu messen.
    Die Klasse kommt aus der standard Bibliothek von .Net. %TODO nochmal nachschauen ob wirklich von standard bib
    Mithilfe der Methoden \textit{Start()} und \textit{Stop()} lässt sich die Stopuhr starten beziehungsweise beenden. Mit der Eigenschaft \textit{ElapsedMilliseconds} lässt sich dann die gemessene Zeit der aktuellen Instanz als long ausgeben.\par
    Hingegen zum messen des Speicherverbrauchs die Klasse GC verwendet wird, die eine Menge von Methoden und Eigenschaften bereitstellt um Speicher zu verwalten.
    Auch diese Klasse stammt aus der standard Bibliothek von .Net. %TODO gleiches wie drüber
    GC hat nicht die Möglichkeit sofort den Speicherverbrauch zu messen, aber mithilfe der Methode \textit{GetTotalMemory()} kann der Speicherverbraucht indirekt berechnet werden.
    \textit{GetTotalMemory()} gibt die Heapgröße ohne Fragmentierung zurück. 
    Wird die Methode vor und nach einer Funktion aufgerufen und die Differenz aus den beiden Zahlen gebildet, dann ergibt sich der Speicherverbrauch der Funktion.\\
    \\
    Da die Testumgebung nicht notwendig für die Funktionalität der Schleifenblöcke ist, wird nur kurz erklärt, wie überprüft wurden ist, ob die Schleifenblöcke funktionieren oder nicht.
    Zum Wiederholen der Messungen für den Speicherverbrauch und die Ausführungszeit wurde eine Batch-Datei erstellt, die die Software regelmäßig Neustartet und die Prüfung aufruft.
    Insgesammt wurden vier Tests erstellt, die jeweils mindestens 50 Messungen pro Schleifenblock beinhaltet.
    Folgende Tests wurden erstellt:
    \begin{itemize}
        \item (T1)
    \end{itemize}
    \textbf{(t1)}\\
    \\
    %TODO: herausfinden für was display existiert
    Im Rahmen dieses Tests wurde die Schleife mit fünf Iterationen und  $Argument1 \geq Argument2$ initialisiert.
    Das Argument1 wird dabei während des Prüfungsvorgang dabei um den Wert zwei erhöht.
    Hingegen Argument2 mit den konstanten Wert 3 initalisiert ist.
    Zu Beginn wird dabei das Argument1 auf Null gesetzt.
    Nach zwei Iteration wird das Argument1 den Wert vier erreichen und dadurch die Abbruchbedingung erfüllen.
    Infolgedessen wird im Display-Block für den Sensor der Wert 4 angezeigt.\\
    \\
    Dieses Szenario wurde ingesammt 100-Mal für den Block A durchgespielt und 108-Mal für den Block B.
    Die Ergebnisse der Messungen wurden in Abbildung TODO grafisch aufbereitet.\\
    \\
    Für die anderen Tests ändert sich nicht viel.
    Lediglich dass die Anzahl der Iterationen bis zum erfüllen der Abbruchbedingung erhöht und die Anzahl an Iterationen angepasst.
    \begin{figure}[H]
        \includegraphics[width=\linewidth]{./image/ausfuehrungszeit-einfach.pdf}
        \caption{Flow-Instanz}
        \label{Flow-Instanz}
    \end{figure}
    Im folgenden werden
    Die anderen Szenarien werden die Anzahl an Iterationen erhöht.
    Die Tests wurden so eingestellt, dass die Abbruchbedingung immer erfüllt wird.
    Im zweiten Szenario ist die Anzahl der Iteration auf 64 erhöht.
    Im dritten Szenario ist die Anzahl der Iteration auf 512 erhöht wurden.
    Im vierten Szenario ist die Anzahl der Iterationen auf 1638 erhöht wurden.
    \begin{figure}[H]
        \includegraphics[width=\linewidth]{./image/ausfuehrungszeit-mittel.pdf}
        \caption{Flow-Instanz}
        \label{Flow-Instanz}
    \end{figure}
    Hingegen bei Block A eine Ausführung in dieser Größenordnung nicht möglich war. 
    Beim ausführen gab es nach einer Zeit einen Overflow der auf den Rekusriven Funktionsaufruf von \textit{CloneAndModify()} zurückzuführen ist.
    Aus dem Grund stehen für dieses Szenario für Block keine Messwerte zur verfügung.
    %\subsection{1. Lösungsansatz}
    %+einfach zu implementieren, da wir kein schleifenkonstrukt mehr benötigen.
    %+keine Endlosschleife, weil es keine Schleifen gibt
    %+keine Zyklen, weil der Ablauf linear ist
    %+weniger Sprünge, weil keine for oder while Bedingungen vorhanden sind
    %+möglicher Performance gewinn, weil Schleifen-Overhead entfällt
    %-größerer Codeumfang, da der eigentliche schleifenkörper a-mal im code implemtniert werden muss 
    %-höherer verbraucht an ressourcen zB Speicher mehr code = mehr speicher
    %-möglicherweise ineffizient, wenn der faktor zu groß gewählt wird
    %-schlechtere Lesbarkeit
    %-wenn bereits nach 3 durchlaufen feststeht, dass das gewünschte ergbeniss nicht mehr erreicht werden kann werden trotzdem die restlichen schritte ausgeführt
    %\subsection{2. Lösungsansatz}
    %+keine Endlosschleife, weil maximale Schleifendurchläufe begrenzt sind.
    %+
    %-azyklisches verhalten wird verletzt, weil schleifenkonstrukt benötigt wird
    %-
    \newpage
    \section{Ausblick}
    %TODO treshold, robustheit dass block a mit 1,6k iterationen arbeiten kann, visualisierung dass ergebnisse nicht eingetroffen ist
    In diesem Kapitel werden mögliche Weiterentwicklung und zukünftige Forschungsarbeiten beschrieben. 
    Die erst im späten Verlauf aufgetreten sind oder aus Zeitgründen nicht bearbeitet werden konnten.\\
    \\
    Der Threhsold für den Algorithmus Block B wird aktuell fest in den Code implementiert werden. 
    Das sollte in der Praxis so nicht sein. 
    Hier würde es sich anbieten einen Algorithmu zu entwerfen der den Threshold dynmaisch anpasst jenachdem welche Eingabe er bekommt.\\
    \\
    Ein anderer Punkt, ist dass derBneutzer aktuell kein Feedback bekommt, ob ein Ergebniss gefunden wurden ist oder nicht.
    Um das zu verbessern könnte eine Meldung ins System implementiert werden, wenn der Algorithmus nicht durchgeht, dass der Benutzer eine Meldung bekommt, dass keine Lösung gefunden werden konnte.\\
    \\
    Ein anderer Punkt der verbessert werden kann, ist die Robustheit des Block A. 
    Dieser führt aktuell bei einer großen Anzahl an Iterationen zu einen Overflow. 
    aus
    \newpage
    \renewcommand{\refname}{}
    \section{Literaturverzeichnis}
    \begin{thebibliography}{9}
        \bibitem{2}Johnston, W., Hanna, J., \& Millar, R. (2004). \emph{Advances in dataflow programming languages}. ACM Computing Surveys, 36(1), 1–34.
        \bibitem{3}Chen, L. (2021). \emph{Iteration vs. Recursion: Two Basic Algorithm Design Methodologies}. SIGACT News, 52(1), 81–86.
        \bibitem{4}Arvind, \& Culler, D. (1986). \emph{Dataflow Architectures}. LCS Technical Memos.
        \bibitem{5}Ambler, A., \& Burnett, M. (1990). \emph{Visual forms of iteration that preserve single assignment}. Journal of Visual Languages \& Computing, 1(2), 159–181.
        \bibitem{6}Mosconi, M., \& Porta, M. (2000). \emph{Iteration constructs in data-flow visual programming languages}. Computer Languages, 26(2), 67–104.
        \bibitem{1}Fan, Z., Li, W., Liu, T., Tang, S., Wang, Z., An, X., Ye, X., \& Fan, D. (2022). \emph{A Loop Optimization Method for Dataflow Architecture}. In 2022 IEEE 24th Int Conf on High Performance Computing \& Communications; 8th Int Conf on Data Science \& Systems; 20th Int Conf on Smart City; 8th Int Conf on Dependability in Sensor, Cloud \& Big Data Systems \& Application (HPCC/DSS/SmartCity/DependSys) (pp. 202–211).
        \bibitem{7}Gévay, G., Soto, J., \& Markl, V. (2021). \emph{Handling Iterations in Distributed Dataflow Systems}. ACM Comput. Surv., 54(9), 199:1–199:38.
        \bibitem{8}Alves, T., Marzulo, L., Kundu, S., \& França, F. (2021). \emph{Concurrency Analysis in Dynamic Dataflow Graphs}. IEEE Transactions on Emerging Topics in Computing, 9(1), 44–54.
        \bibitem{9}Ye, Z., \& Jiao, J. (2024). \emph{Loop Unrolling Based on SLP and Register Pressure Awareness}. In 2024 20th International Conference on Natural Computation, Fuzzy Systems and Knowledge Discovery (ICNC-FSKD) (pp. 1–6).
        \bibitem{10}Lučanin, D., \& Fabek, I. (2011). \emph{A visual programming language for drawing and executing flowcharts}. In 2011 Proceedings of the 34th International Convention MIPRO (pp. 1679–1684).
        \bibitem{11}Davis, A., \& Keller, R. (1982). \emph{Data Flow Program Graphs}. All HMC Faculty Publications and Research.
        \bibitem{21}Boshernitsan, M., \& Downes, M. (2004). \emph{Visual Programming Languages: A Survey}. EECS University of California, Berkeley.
        \bibitem{12}Charntaweekhun, K., \& Wangsiripitak, S. (2006). \emph{Visual Programming using Flowchart}. In 2006 International Symposium on Communications and Information Technologies (pp. 1062–1065).
        \bibitem{13}Burnett, M., Baker, M., Bohus, C., Carlson, P., Yang, S., \& Van Zee, P. (1995). \emph{Scaling up visual programming languages}. Computer, 28(3), 45–54.
        \bibitem{14}Kurihara, A., Sasaki, A., Wakita, K., \& Hosobe, H. (2015). \emph{A Programming Environment for Visual Block-Based Domain-Specific Languages}. Procedia Computer Science, 62, 287–296.
        \bibitem{15}Hils, D. (1992). \emph{Visual languages and computing survey: Data flow visual programming languages}. Journal of Visual Languages \& Computing, 3(1), 69–101.
        \bibitem{19}Sousa, T. (2012). \emph{Dataﬂow Programming Concept, Languages and Applications}. Doctoral Symposium on Informatics Engineering, 7.
        \bibitem{18}Van Deursen, A., Klint, P., \& Visser, J. (2000). \emph{Domain-specific languages: an annotated bibliography}. ACM SIGPLAN Notices, 35(6), 26–36.
        \bibitem{16}Roy, G., Kelso, J., \& Standing, C. (1998). \emph{Towards a visual programming environment for software development}. In Proceedings. 1998 International Conference Software Engineering: Education and Practice (Cat. No.98EX220) (pp. 381–388). IEEE Comput. Soc.
        \bibitem{20}Weintrop, D. (2019). \emph{Block-based programming in computer science education}. Communications of the ACM, 62(8), 22–25.
        \bibitem{22}Gumm, H.P., \& Sommer, M. (2016). \emph{Band 1 Programmierung, Algorithmen und Datenstrukturen}. De Gruyter Oldenbourg.
    \end{thebibliography}
\end{document}    